
- [选择排序](#选择排序)
- [冒泡排序](#冒泡排序)
- [链表](#链表)
  - [反转链表](#反转链表)
- [数组](#数组)
  - [轮转数组](#轮转数组)
- [哈希](#哈希)
  - [俩数之和](#俩数之和)
- [栈](#栈)
  - [有效的括号](#有效的括号)
  - [每日温度](#每日温度)
- [树](#树)
  - [二叉搜索树中第 K 小的元素](#二叉搜索树中第-k-小的元素)
  - [求根节点到叶节点数字之和](#求根节点到叶节点数字之和)
  - [二叉树的最近公共祖先](#二叉树的最近公共祖先)
- [单指针](#单指针)
  - [颜色分类](#颜色分类)
- [双指针](#双指针)
  - [移动零](#移动零)
  - [比较版本号](#比较版本号)
  - [盛最多水的容器](#盛最多水的容器)
- [贪心算法](#贪心算法)
  - [最长回文串](#最长回文串)
  - [买卖股票的最佳时机](#买卖股票的最佳时机)
  - [跳跃游戏](#跳跃游戏)

## 选择排序
新建中间商 依次比较 找出极值 放入目标位置 比较n轮
```c#
static void SelectionSort(int[] arr,bool isAscend)
{
    int index;
    int temp;
    for (int i = 0; i < arr.Length; i++)
    {
        index = 0;

        for (int j = 1; j < arr.Length - i; j++)
        {
            if (arr[index] < arr[j]) 
            {
                index = j;
            }

        }
        if (index!= arr.Length - 1 - i)
        {
            temp = arr[index];
            arr[index] = arr[arr.Length - 1 - i];
            arr[arr.Length - 1 - i] = temp;
        }
    }       
}
```
## 冒泡排序
8 7 1 5 3 8 9
排序成有序序列 1 3 5 7 8 8 9 升序 9 8 8 7 5 3 1 降序    
序列一般存储在数组中            
原理            
俩俩相邻 不停交换 不停比较      
```c#
static void Bubble(int[] arr)
{
    for (int j = 0; j < arr.Length; j++)
    {
        for (int i = 0; i < arr.Length - 1; i++)
        {
            if (arr[i] > arr[i + 1])
            {
                int temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
            }
        }
    }
}
```
优化 不用再去比较已经确定位置的数字           
```c#
static void Bubble(int[] arr)
{
    for (int j = 0; j < arr.Length; j++)
    {
        for (int i = 0; i < arr.Length - 1 -j; i++)//减了j轮
        {
            if (arr[i] > arr[i + 1])
            {
                int temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
            }
        }
    }
}
```
特殊情况 如果数组是 9 0 1 2 3 4 5 6 7 8 只要排一轮就完成了 其余轮次浪费性能
```c#
//标识 isSort 是否进行了交换
static void Bubble(int[] arr)
{
    bool isSort = false;
    int temp;
    for (int j = 0; j < arr.Length; j++)
    {
        isSort = false; //每轮默认没有进行交换
        for (int i = 0; i < arr.Length - 1 -j; i++) //减了j轮
        {
            if (arr[i] > arr[i + 1])
            {
                isSort = true; //进行了交换
                temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
            }
        }
        if(!isSort)
        {
        break;//没有进行交换 确认已经完成了排序 跳出循环
        }
    }
    
}

```

## 链表
### 反转链表

![](Image/2025-02-21-19-48-38.png)
LeedCode 206
``` c#
public class Solution {
    public ListNode ReverseList(ListNode head) {
        ListNode current = head;
        ListNode pre = null;
        while(current!=null)
        {
            ListNode temp = current.next;
            current.next = pre; 
            pre = current;
            current = temp;
        }
        return pre;
    }
}
```
## 数组
### 轮转数组
![](Image/2025-02-21-22-08-37.png)
``` c#
public class Solution {
    public void Rotate(int[] nums, int k) {
        int n = nums.Length;
        int[] temp = new int[n];
        for(int i=0; i < n; ++i)
        {
            temp[(i+k)%n] = nums[i];
        }
        for(int i=0; i < n; ++i)
        {
            nums[i] = temp[i];
        }
    }
}
```

## 哈希

### 俩数之和
![](Image/2025-02-21-22-08-19.png)
1
``` c#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        for(int i = 0; i<nums.Length;i++)
        {
            for(int j = i+1; j<nums.Length;j++)
            {
                if(nums[i]+nums[j]==target)
                {
                   return new int[]{i, j};
                }
            }

        }
        return new int[]{-1, -1};
    }
}

```
``` c#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> dictionary = new Dictionary<int, int>();
        int length = nums.Length;
        
        for(int i = 0; i<length;i++ )
        {
            int num = nums[i];
            if (dictionary.ContainsKey(target - num)) 
            {
                int temp = dictionary[target - num];
                return new int[]{temp, i};
            }
            dictionary.TryAdd(num,i);
        }
        return new int[]{-1, -1};
    }
}

```

## 栈
### 有效的括号
![](Image/2025-02-21-22-59-52.png)

``` c#
public class Solution {
    public bool IsValid(string s) {
        int num = s.Length;
        if(num % 2==1 )
            return false;
        Stack<char> stack = new Stack<char>();
        for(int i = 0; i<num; i++)
        {
            if(s[i] == '(')
                stack.Push(')');
            else if(s[i] == '[')
                stack.Push(']');
            else if(s[i] == '{')
                stack.Push('}');
            else if(stack.Count == 0 || stack.Pop() != s[i])
                return false;
        }
        if(stack.Count > 0)
            return false;
        else 
            return true;
    }
}
```
### 每日温度
![](Image/2025-02-22-13-45-35.png)
``` C#
public class Solution {
    public int[] DailyTemperatures(int[] temperatures) {
        int length = temperatures.Length;
        int[] answer = new int[length];
        Stack<int> stack = new Stack<int>();
        for (int i = 0; i < length; i++) {
            int temperature = temperatures[i];
            while (stack.Count > 0 && temperatures[stack.Peek()] < temperature) {
                int j = stack.Pop();
                answer[j] = i - j;
            }
            stack.Push(i);
        }
        return answer;
    }
}

```
## 树
树有个特质 左边节点是小于根节点的 右边是大于根节点的
**中序遍历**
访问左子树——根结点——右子树的方式遍历二叉树
### 二叉搜索树中第 K 小的元素
![](Image/2025-02-22-15-11-14.png)
``` c#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public int KthSmallest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<TreeNode>();
        while (root != null || stack.Count > 0) 
        {
            while (root != null) 
            {
                stack.Push(root);
                root = root.left;
            }
            root = stack.Pop();
            --k;
            if (k == 0) 
            {
                break;
            }
            root = root.right;
        }
        return root.val;
    }
}
```

### 求根节点到叶节点数字之和

![](Image/2025-02-22-15-41-27.png)

``` c#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution 
{
    public int dfs(TreeNode root, int preSum)
    {
        if(root == null)
            return 0;
        int sum = preSum*10 + root.val;
        if(root.left == null && root.right == null)
            return sum;
        else
            return dfs(root.left, sum) + dfs(root.right, sum);
        
    }

    public int SumNumbers(TreeNode root) 
    {
        return dfs(root, 0);
    }
}
```
### 二叉树的最近公共祖先

![](Image/2025-02-22-15-59-40.png)

``` c#
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    TreeNode ans;
    public bool dfs(TreeNode root, TreeNode p, TreeNode q) 
    {
        if (root == null) 
            return false;
        bool lson = dfs(root.left, p, q); // p,q是否在左节点中 //2-t
        bool rson = dfs(root.right, p, q);// p,q是否在右节点中

        // 第一种情况lson rson 分别包含p q
        // 第二种情况p,q是root 然后 子节点包含了另一个
        if ((lson && rson) || ((root.val == p.val || root.val == q.val) && (lson || rson))) {
            ans = root;
        } 
        return lson || rson || (root.val == p.val || root.val == q.val);
    }

    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) 
    {
        dfs(root, p, q);
        return ans;
    }
}
```
## 单指针
### 颜色分类

![](Image/2025-02-22-17-58-10.png)

``` c#
public class Solution {
    public void SortColors(int[] nums) {
        int n = nums.Length;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                Swap(nums, i, index);
                index++;
            }
        }
        for (int i = index; i < n; i++) {
            if (nums[i] == 1) {
                Swap(nums, i, index);
                index++;
            }
        }
    }

    public void Swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}

```

## 双指针
### 移动零
![](Image/2025-02-22-18-18-46.png)

``` c#
public class Solution {
    public void Swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
    public void MoveZeroes(int[] nums) 
    {  
        int length = nums.Length;
        int left = 0;
        int right = 0;
        
        while(right<length)
        {
            if( nums[right] != 0)
            {
                Swap(nums,left,right);
                left++;
            }
            right++;
        }
    }
}
```
### 比较版本号
![](Image/2025-02-23-10-43-40.png)

**暴力法**
``` c#
public class Solution {
    public int CompareVersion(string version1, string version2) {
        string[] str1 = version1.Split('.');
        string[] str2 = version2.Split('.');
        
        for(int i = 0; i<str1.Length||i<str2.Length; i++)
        {
            int x = 0,y = 0;
            if(i<str1.Length) 
                x = int.Parse(str1[i]);
            if(i<str2.Length) 
                y = int.Parse(str2[i]);
            if(x<y)
                return -1;
            if(x>y)
                return 1;
        }
        return 0;


    }
}
```
**双指针**
``` c#
public class Solution {
    public int CompareVersion(string version1, string version2) {
        int n = version1.Length, m = version2.Length;
        int i = 0, j = 0;
        while (i < n || j < m) {
            int x = 0;
            for (; i < n && version1[i] != '.'; ++i) {
                x = x * 10 + version1[i] - '0';
            }
            ++i; // 跳过点号
            int y = 0;
            for (; j < m && version2[j] != '.'; ++j) {
                y = y * 10 + version2[j] - '0';
            }
            ++j; // 跳过点号
            if (x != y) {
                return x > y ? 1 : -1;
            }
        }
        return 0;
    }
}
```
### 盛最多水的容器
![](Image/2025-02-23-13-23-01.png)
``` c#
public class Solution {
    public int MaxArea(int[] height)
    {
        int max = 0;
        int left=0,right = height.Length-1;
        int current = 0;
        while(left != right)
        {
            current = 0;
            if(height[left] < height[right])
            {   
                current = height[left] * (right - left);
                left++;
            }
            else 
            {
                current = height[right] * (right - left);
                right--;
            }
            if(current > max)
                max = current;
        }
        return max;

    }
}
```

## 贪心算法
贪心算法（greedy algorithm，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择
### 最长回文串
![](Image/2025-02-23-14-48-51.png)
``` c#
public class Solution {
    public int LongestPalindrome(string s) {
        Dictionary<char, int> charCount = new Dictionary<char, int>();

        // 统计每个字符的出现次数
        for (int i = 0; i < s.Length; i++) {
            if (charCount.ContainsKey(s[i])) {
                charCount[s[i]]++;
            } else {
                charCount[s[i]] = 1;
            }
        }
        int length = 0;
        bool hasOdd = false;
 
        // 遍历字符计数，计算回文串长度
        foreach (var item in charCount) {
            /// 逻辑上，对于每个字符，如果其出现次数是奇数，
            /// 我们可以将其所有偶数次的字符用于回文串中，
            ///并额外添加一个字符到回文串的中心（如果有的话）。
            int count = item.Value;
            length += count / 2 * 2; // 添加偶数次字符
            if (  % 2 != 0 && !hasOdd) {
                hasOdd = true; // 标记存在奇数次字符
            }
        }
 
        // 如果存在奇数次字符，则回文串长度加1（中心字符）
        return hasOdd ? length + 1 : length;
    }
}
```

### 买卖股票的最佳时机
![](Image/2025-02-23-15-19-38.png)

``` c#
public class Solution {
    public int MaxProfit(int[] prices) {
        int ans = 0;
        int n = prices.Length;
        for(int i = 1; i<n; i++)
        {
            ans += Math.Max(0,prices[i] - prices[i-1]);
        }
        return ans;
    }
}
```

### 跳跃游戏
![](Image/2025-02-23-15-45-14.png)
``` c#
public class Solution {
    public bool CanJump(int[] nums) {
        int length = nums.Length;
        int currentL = 0;
        for(int i = 0 ; i < length; i++)
        {
            if(i<=currentL)
            {
                currentL = Math.Max(currentL,nums[i] + i);
                if(currentL >= length-1)
                    return true;
            }
        }
        
        return false;
    }
}
```