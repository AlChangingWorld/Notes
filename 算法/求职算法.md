
- [选择排序](#选择排序)
- [冒泡排序](#冒泡排序)
- [链表](#链表)
  - [反转链表](#反转链表)
- [数组](#数组)
- [轮转数组](#轮转数组)
- [哈希](#哈希)
  - [俩数之和](#俩数之和)
- [栈](#栈)
  - [有效的括号](#有效的括号)

## 选择排序
新建中间商 依次比较 找出极值 放入目标位置 比较n轮
```c#
static void SelectionSort(int[] arr,bool isAscend)
{
    int index;
    int temp;
    for (int i = 0; i < arr.Length; i++)
    {
        index = 0;

        for (int j = 1; j < arr.Length - i; j++)
        {
            if (arr[index] < arr[j]) 
            {
                index = j;
            }

        }
        if (index!= arr.Length - 1 - i)
        {
            temp = arr[index];
            arr[index] = arr[arr.Length - 1 - i];
            arr[arr.Length - 1 - i] = temp;
        }
    }       
}
```
## 冒泡排序
8 7 1 5 3 8 9
排序成有序序列 1 3 5 7 8 8 9 升序 9 8 8 7 5 3 1 降序    
序列一般存储在数组中            
原理            
俩俩相邻 不停交换 不停比较      
```c#
static void Bubble(int[] arr)
{
    for (int j = 0; j < arr.Length; j++)
    {
        for (int i = 0; i < arr.Length - 1; i++)
        {
            if (arr[i] > arr[i + 1])
            {
                int temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
            }
        }
    }
}
```
优化 不用再去比较已经确定位置的数字           
```c#
static void Bubble(int[] arr)
{
    for (int j = 0; j < arr.Length; j++)
    {
        for (int i = 0; i < arr.Length - 1 -j; i++)//减了j轮
        {
            if (arr[i] > arr[i + 1])
            {
                int temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
            }
        }
    }
}
```
特殊情况 如果数组是 9 0 1 2 3 4 5 6 7 8 只要排一轮就完成了 其余轮次浪费性能
```c#
//标识 isSort 是否进行了交换
static void Bubble(int[] arr)
{
    bool isSort = false;
    int temp;
    for (int j = 0; j < arr.Length; j++)
    {
        isSort = false; //每轮默认没有进行交换
        for (int i = 0; i < arr.Length - 1 -j; i++) //减了j轮
        {
            if (arr[i] > arr[i + 1])
            {
                isSort = true; //进行了交换
                temp = arr[i + 1];
                arr[i + 1] = arr[i];
                arr[i] = temp;
            }
        }
        if(!isSort)
        {
        break;//没有进行交换 确认已经完成了排序 跳出循环
        }
    }
    
}

```

## 链表
### 反转链表

![](Image/2025-02-21-19-48-38.png)
LeedCode 206
``` c#
public class Solution {
    public ListNode ReverseList(ListNode head) {
        ListNode current = head;
        ListNode pre = null;
        while(current!=null)
        {
            ListNode temp = current.next;
            current.next = pre; 
            pre = current;
            current = temp;
        }
        return pre;
    }
}
```
## 数组
## 轮转数组
![](Image/2025-02-21-22-08-37.png)
``` c#
public class Solution {
    public void Rotate(int[] nums, int k) {
        int n = nums.Length;
        int[] temp = new int[n];
        for(int i=0; i < n; ++i)
        {
            temp[(i+k)%n] = nums[i];
        }
        for(int i=0; i < n; ++i)
        {
            nums[i] = temp[i];
        }
    }
}
```

## 哈希

### 俩数之和
![](Image/2025-02-21-22-08-19.png)
1
``` c#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        for(int i = 0; i<nums.Length;i++)
        {
            for(int j = i+1; j<nums.Length;j++)
            {
                if(nums[i]+nums[j]==target)
                {
                   return new int[]{i, j};
                }
            }

        }
        return new int[]{-1, -1};
    }
}

```
``` c#
public class Solution {
    public int[] TwoSum(int[] nums, int target) {
        Dictionary<int, int> dictionary = new Dictionary<int, int>();
        int length = nums.Length;
        
        for(int i = 0; i<length;i++ )
        {
            int num = nums[i];
            if (dictionary.ContainsKey(target - num)) 
            {
                int temp = dictionary[target - num];
                return new int[]{temp, i};
            }
            dictionary.TryAdd(num,i);
        }
        return new int[]{-1, -1};
    }
}

```

## 栈
### 有效的括号
![](Image/2025-02-21-22-59-52.png)

``` c#
public class Solution {
    public bool IsValid(string s) {
        int num = s.Length;
        if(num % 2==1 )
            return false;
        Stack<char> stack = new Stack<char>();
        for(int i = 0; i<num; i++)
        {
            if(s[i] == '(')
                stack.Push(')');
            else if(s[i] == '[')
                stack.Push(']');
            else if(s[i] == '{')
                stack.Push('}');
            else if(stack.Count == 0 || stack.Pop() != s[i])
                return false;
        }
        if(stack.Count > 0)
            return false;
        else 
            return true;
    }
}
```