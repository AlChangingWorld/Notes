
- [一、基础部分](#一基础部分)
  - [1.值类型和引用类型有什么区别](#1值类型和引用类型有什么区别)
  - [2.重载和重写的区别](#2重载和重写的区别)
  - [3. ArrayList和 List的主要区别](#3-arraylist和-list的主要区别)
  - [4. List底层是什么实现的?](#4-list底层是什么实现的)
  - [5. LinkedList和List区别?](#5-linkedlist和list区别)
  - [6. 请描述Interface与抽象类之间的不同](#6-请描述interface与抽象类之间的不同)
  - [7. 构造函数是否能被重写？](#7-构造函数是否能被重写)
  - [8. 静态成员和⾮静态成员的区别](#8-静态成员和静态成员的区别)
  - [9.C#中ref和out关键字有什么区别？](#9c中ref和out关键字有什么区别)
  - [10.字符串中string str=null和string str=""和string str=string.Empty的区别？](#10字符串中string-strnull和string-str和string-strstringempty的区别)
  - [11.const和readonly有什么区别？](#11const和readonly有什么区别)
  - [12. 函数中多次使用string的+=处理，会产生大量内存垃圾(垃圾碎片)，有什么好的方法可以解决。](#12-函数中多次使用string的处理会产生大量内存垃圾垃圾碎片有什么好的方法可以解决)
  - [13.  String s = new String(“xyz”);创建了⼏个String Object?](#13--string-s--new-stringxyz创建了个string-object)
  - [14. C#是否可以继承String类?](#14-c是否可以继承string类)
  - [15. 简述StringBuilder和String的区别？(字符串处理)](#15-简述stringbuilder和string的区别字符串处理)
  - [16.结构体和类有何区别?](#16结构体和类有何区别)
  - [17. C#两个对像值相同(x.equals(y)== true)，但却可有不同的hashcode，这句话对不对？](#17-c两个对像值相同xequalsy-true但却可有不同的hashcode这句话对不对)
  - [18. ⽤最有效的⽅法算出2乘以8等于⼏?](#18-最有效的法算出2乘以8等于)
  - [19. int? 和 int有什么区别?](#19-int-和-int有什么区别)
  - [20. i++ 和 ++i 有什么区别？](#20-i-和-i-有什么区别)
  - [21. C#语言中的sleep() 和 wait() 有什么区别?](#21-c语言中的sleep-和-wait-有什么区别)
  - [22.  概述C#反射和序列？](#22--概述c反射和序列)
  - [23. C# sealed修饰符有什么特点?](#23-c-sealed修饰符有什么特点)
  - [24.数组遍历一般用for、foreach，有什么区别？](#24数组遍历一般用forforeach有什么区别)
- [中级部分](#中级部分)
  - [1. c#可否对内存直接操作](#1-c可否对内存直接操作)
  - [2. 什么是匿名⽅法？](#2-什么是匿名法)
  - [3. 什么是闭包？](#3-什么是闭包)
  - [4. CTS、CLS、CLR分别是什么？](#4-ctsclsclr分别是什么)
  - [5. 什么是装箱和拆箱？如何避免效率问题？](#5-什么是装箱和拆箱如何避免效率问题)
  - [6. C#中有哪些常用的容器类，各有什么特点](#6-c中有哪些常用的容器类各有什么特点)
  - [7.构造函数是否能被重写？](#7构造函数是否能被重写)
  - [8.C#中using的三种用法](#8c中using的三种用法)

## 一、基础部分

### 1.值类型和引用类型有什么区别
**值类型** 包括所有的数值类型 struct 枚举       
**引用类型** 类 数组 接口 string delegate 

- 存储空间不同
值类型是存储在栈中 内存是自动释放的
引用类型存储在堆中  内存需要GC来释放 

- 值类型 存取速度块, 引用类型慢

- 值类型代表的是实际数据, 引用类型代表 在栈中存储在堆中的地址 在堆中存储真正的数据
类中 值类型成员也在堆中，而引用类型成员数据类型也会在堆里 引用在类数据部分中

- 值类型在赋值时把内容拷贝给了对方 他变我不变, 引用类型在赋值时 让俩者指向了同一内存地址 他变我也变

- 引用类型继承于万物之父Object, 值类型继承于System.ValueType


### 2.重载和重写的区别
重载 是指函数重载 参数类型、数量、顺序的不同调用不同的函数          
重写是override 在父类和子类中使用这个方法时 调用的是重写过的方法            

- 封装、继承、多态所处位置不同，重载在同类中，重写在父子类中。          
- 定义方式不同，重载方法名相同参数列表不同，重写方法名和参数列表都相同。                
- 调用方式不同，重载使用相同对象以不同参数调用，重写用不同对象以相同参数调用。              
- 多态时机不同，重载时编译时多态，重写是运行时多态。


### 3. ArrayList和 List的主要区别           
- ArrayList 不带泛型 数据类型丢失 存储的是Object类型存在装箱拆箱 操作费时
List 带泛型 数据类型不丢失 List是泛型方法 不存在装箱拆箱的问题          

- ArrayList存在不安全类型(ArrayList会把所有插⼊其中的数据都当做Object来处理)装箱拆箱的 操作(费时)               
- IList是接⼝，ArrayList是⼀个实现了该接⼝的类，可以被实例化              
- List类是ArrayList类的泛型等效类。它的大部分用法都与ArrayList相似，因为List类也继承了IList接口。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。             

     


### 4. List底层是什么实现的?
List它的底层实现是使用数组。List类中的元素可以通过索引来访问，并且在索引越界时会抛出异常。
当你对List中的元素进行增加操作时，List会自动重新分配内存以适应变化后的大小。List底层的数组会在元素数量不够时扩容。所以最好是一开始就初始化好数量，而不是一个一个add进去。

List底层有一个自动扩容 刚开始16 后面32会翻倍的往上加
所以不需要这事先确定容量大小
具体扩容: 当向列表中添加元素并且列表的容量不足以容纳新元素时，List<T> 会进行扩容。扩容操作通常会将数组的大小增加一倍(尽管这不是固定的，并且可能因实现而异)，并将现有元素复制到新的数组中。扩容操作的时间复杂度是 O(n)，但由于它只在需要时发生，因此平均下来对性能的影响较小。

### 5. LinkedList和List区别?
List是一个基于数组的数据结构，可以随机访问列表中的任何元素。当需要添加或删除元素时，List需要重新分配内存空间，因此插入或删除操作可能会导致性能下降。List适用于需要随机访问元素的场景，例如需要按索引进行访问或排序等操作。查改出色

LinkedList是一个基于链表的数据结构，双向链表, 它不支持随机访问元素。要访问列表中的任何元素，必须从头节点开始遍历整个列表。但是，插入或删除元素时，LinkedList只需要调整节点指针，因此插入或删除操作的性能通常比List更高。LinkedList适用于需要频繁插入或删除元素的场景

### 6. 请描述Interface与抽象类之间的不同
1. 接口不是类 不能实例化 抽象类可以间接实例化 可以通过实例化子类对象来调用抽象类中的方法 
2. 接口是完全抽象 方法可以实现不过能覆盖 抽象类为部分抽象 在抽象类中 可以当正常类来写 只不过不能实例化
3. 接口可以多继承 抽象类是单继承
4. 接口中可以有静态成员 方法、属性、事件和索引器

### 7. 构造函数是否能被重写？
不能 但是可以重载 构造器Constructor不能被继承


### 8. 静态成员和⾮静态成员的区别
- 静态成员 ⽤statis修饰符声明 存储在静态区里 可以通过类名.的形式获取 全局都是一个 类被第一次加载到内存时创建
- 非静态成员在对象被实例化时创建 只能通过实例化来获取
- 静态⽅法⾥不能使⽤⾮静态成员，⾮静态⽅法可以使⽤静态成员 

### 9.C#中ref和out关键字有什么区别？

- ref修饰引用参数。参数必须赋值，带回返回值，又进又出 传入的值必须初始化
- out修饰输出参数。参数可以不赋值，带回返回值之前必须明确赋值，传入的每一个输出参数必须在内部赋值
- 引用参数和输出参数不会创建新的存储位置
- 如果ref参数是值类型，原先的值类型数据，会随着方法里的数据改变而改变，
- 如果ref参数值引用类型，方法里重新赋值后，原对象堆中数据会改变，如果对引用类型再次创建新对象并赋值给ref参数，引用地址会重新指向新对象堆数据。
```c#
int i;
changeRef(ref i);   // 报错
changeOut(out i);   // 不报错 但是必须在函数中赋值
```

### 10.字符串中string str=null和string str=""和string str=string.Empty的区别？
- string.Empty相当于“”,Empty是⼀个静态只读的字段。 
- string str="" ,初始化对象，并分配⼀个空字符串的内存空间 
- string str=null,初始化对象，不会分配内存空间


### 11.const和readonly有什么区别？          
都可以标识⼀个常量。必须初始化 不能被修改       
主要有以下区别:                 
1. 初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值，也可以构造⽅法⾥赋值。        
2. const是编译时常量，在编译时确定该值；readonly是运⾏时常量，在运⾏时确定该值。        
3. const默认是静态的；⽽readonly如果设置成静态需要显示声明 static       
4. 修饰引⽤类型时不同，const只能修饰 值类型和string或值为null的其他引⽤类型；readonly可以是任何类型。        


### 12. 函数中多次使用string的+=处理，会产生大量内存垃圾(垃圾碎片)，有什么好的方法可以解决。
string是个特殊的引用类型 每一次重新赋值或者拼接会分配新的内存空间
通过StringBuilder 需要频繁修改和拼接的字符串 那进行append，这样可以减少内存垃圾 在最开始 给定容量 超过会扩容乘2


### 13.  String s = new String(“xyz”);创建了⼏个String Object?
两个对象，⼀个是“xyz”,⼀个是指向“xyz”的引⽤对象s.
当使用 new string("xyz"); 时，会在堆上创建一个新的 string 对象

“xyz” 存在于了字符串驻留池
字符串驻留池的核心概念是确保具有相同值的字符串在内存中只有一个实例。
工作原理如下
当你在代码中使用字符串字面值时, 编译器会将这些字符串字面值存储在字符串驻留池中。这是编译时的操作 不是运行时操作。
2.检查字符串值:在创建字符串字面值时，编译器会首先检査字符串池，看是否已经存在具有相同值的字符串。如果存在，编译器会返回对现有字符串的引用，而不是创建-个新的字符串对象,

### 14. C#是否可以继承String类?
不能，类似于sealed修饰过，String在.Net里有特殊处理过。

### 15. 简述StringBuilder和String的区别？(字符串处理)
String是字符串常量，线程安全。
StringBuilder是字符串变量，线程不安全。
- String类型是个不可变的对象，当每次对String进⾏改变时都需要⽣成⼀个新的String对象，然后将指针指向⼀个新的对象，如果在⼀个循环⾥⾯，不断的改变⼀个对象，就要不断的⽣成新的对象，所以效率很低，建议在不断更改String对象的地⽅不要使⽤String类型。
- StringBuilder对象在做字符串连接操作时是在原来的字符串上进⾏修改，改善了性能。同一块内存地址 这⼀点我们平时使⽤中也许都知道，连接操作频繁的时候，使⽤StringBuilder对象。方法少一些

string线程安全。由于是不可变的，每次修改都会创建新对象，因此在多线程环境中，sting是线程安全的，因为多个线程读取同-string对象不会发生冲突，不需要额外的同步机制。你用你的 我用我的

在多线程环境下，StringBuilder 不保证线程安全。这是因为 StringBuilder 的方法没有进行同步处理，当多个线程同时对同一个 StringBuilder 对象进行操作时，可能会出现数据不一致的情况。例如，一个线程正在执行 append 操作，而另一个线程同时执行 delete 操作

### 16.结构体和类有何区别?

- 结构体是值类型,存储在栈上 类是引用类型,存储在堆上
- 结构体不能够继承 类可以继承
- 结构体不能声明析构函数 类可以
- 结构体不能是静态结构体 静态类可以
- 结构体也能使用接口
结构体的属性和字段可以能初始化 但是需要一个public的构造函数

### 17. C#两个对像值相同(x.equals(y)== true)，但却可有不同的hashcode，这句话对不对？
不对，有相同的hashcode。
(1) 如果两个对象相同(equals方法返回true)，那么它们的hashCode值一定要相同；
(2) 如果两个对象的hashCode相同，它们并不一定相同。因为存在哈希冲突
哈希码的目的是为了优化性能，而不是唯一标识对象。因此: 

如果两个对象的值不同(x.Equals(y) == false)，它们的哈希码可以相同，也可以不同。
哈希码相同并不会影响程序的正确性，只是可能会导致哈希冲突，稍微降低性能。
字符串 "Aa" 和 "BB" 的哈希码计算结果是相同的(哈希冲突)
Dictionary、HashSet 用的都是底层哈希码
快速定位: 通过哈希码直接定位到存储位置，避免遍历整个数据集。
减少比较次数: 只需要在同一个“桶”中的少量对象中进行比较。
理想时间复杂度: 从 O(n) 降低到 O(1)。

### 18. ⽤最有效的⽅法算出2乘以8等于⼏? 
位运算是最快，使⽤的是位运算 逻辑左位移<<。 ⽅法是2<<3 相当于0000 0000 0000 0010 (2的16位int⼆进制) 2的3次方 左移三位就是 0000 0000 0001 0000 (16的⼆进制)

### 19. int? 和 int有什么区别?

int?为可空类型, Nullable<int>是个结构体, 默认值可以是null 
安全获取可空类型 如果为空 返回默认值 int默认值是0 

可以帮助我们自动判断o是否为空 比如事件的invoke的时候

### 20. i++ 和 ++i 有什么区别？
i++ 是先赋值，再⾃增；++i 是先⾃增，再赋值。

### 21. C#语言中的sleep() 和 wait() 有什么区别?
sleep()方法是将当前线程挂起指定的时间。线程的休眠 1000毫秒 = 1秒 
wait()释放对象上的锁并阻塞当前线程，直到它重新获取该锁

### 22.  概述C#反射和序列？
反射: 公共语言运行库加载器管理应用程序域。这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。

序列化: 序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据

### 23. C# sealed修饰符有什么特点?
sealed 修饰符表示密封
用法: 
1.用于类时，表示该类不能再被继承，不能和abstract同时使用，因为这两个修饰符在含义上互相排斥

2.用于方法和属性时，表示该方法或属性不能再被重写，必须和override关键字一起使用，因为使用sealed修饰符的方法和属性肯定是基类中相应的虚成员。
让虚方法或者抽象方法之后不能再被重写.
常见用处: 
1.通常在实现第三方类库时不想被客户端继承，或用于没有必要再继承的类以防止滥用继承造成层次结构体系混乱。
2.恰当的利用sealed修饰符也可以提高一定的运行效率，因为不用考虑继承类会重写该成员。

### 24.数组遍历一般用for、foreach，有什么区别？
可以用**foreach**遍历的类 都是实现了迭代器的   
foreach也称为只读循环,所以在循环数组/集合的时候,无法对数组/集合进行修改 
因为是复制的副本索引 对于值类型不能修改。引用类型可以修改对象的属性

给定长度 不需要计算长度的 for比foreach循环效率高，在不确定长度 或者计算长度有性能损耗的时候 用foreach比较方便。foreach循环的时候会释放使用完的资源,所以会造成额外的gc开销

## 中级部分
### 1. c#可否对内存直接操作
C#在unsafe 模式下可以使⽤指针对内存进⾏操作, 但在托管模式下不可以使⽤指针，C#NET默认不运⾏带指针的，需要设置下，选择项⽬右键->属性->选择⽣成->“允许不安全代码”打勾->保存
``` c#
unsafe
{
    int value = 42;
    int* pointer = &value; // 获取 value 的地址
    *pointer = 100; // 直接修改内存中的值
    Console.WriteLine(value); // 输出: 100
}
``` 
### 2. 什么是匿名⽅法？
匿名⽅法是⽤作委托的参数的⼀段代码。
``` c#
Func<int, int> anon = delegate(int i) 
{ 
 i = i+1; 
 return i; 
}; 
//输出2 
Console.WriteLine(anon(1)); 
//匿名⽅法,例2 
Action<int> anon2 = delegate(int i) 
{ 
 i = i + 1; 
}; 
//输出2 
Console.WriteLine(anon(1));
```

### 3. 什么是闭包？
通过Lambda表达式可以访问Lambda表达式块外部的变量，这成为闭包。 
当引⽤外部变量时，需要注意，外部变量变化时，lambda表达式的结果也可能会随着外部变量变化⽽变 
化。 
**内层的函数可以引用包含在它外层函数的变量**        
**即使外层函数的执行已经终止**       
**临时变量进入委托和事件后生命周期会改变**   
**在闭包情况下临时变量不会被释放**
**该变量提供的值并非变量创建时的值 而是在父函数范围内的最终值**    

### 4. CTS、CLS、CLR分别是什么？
CTS: 通⽤语⾔系统。CLS: 通⽤语⾔规范。CLR: 公共语⾔运⾏库。 
CTS: Common Type System 通⽤类型系统。Int32、Int16→int、String→string、Boolean→bool。 
每种语⾔都定义了⾃⼰的类型，.Net通过CTS提供了公共的类型，然后翻译⽣成对应的.Net类型。 
CLS: Common Language Specification 通⽤语⾔规范。不同语⾔语法的不同。每种语⾔都有⾃⼰的 
语法，.Net通过CLS提供了公共的语法，然后不同语⾔翻译⽣成对应的.Net语法。 
CLR: Common Language Runtime 公共语⾔运⾏时，就是GC、JIT等这些。有不同的CLR，⽐如服务 
器CLR、Linux CLR(Mono)、Silverlight CLR(CoreCLR)。相当于⼀个发动机，负责执⾏IL。

### 5. 什么是装箱和拆箱？如何避免效率问题？
**装箱拆箱问题** 

**装箱**----object存值类型      
把值类型用引用类型存储  把值类型实例转换为引用类型实例    
栈内存会迁移到堆内存中          
``` c#      
Object i = 12; //栈中存放堆地址 堆中存放12      
```  

**拆箱**----拿出来使用 objcet转为值类型 拆箱是显示转换      
把引用类型存储的值类型取出来   把引用类型实例转换为值类型实例     
堆内存会迁移到栈内存中          
``` c#
object v=3;                 
int intValue = (int)v;  //使用需要强制转换
``` 
**好处是** 不确定类型时可以方便参数的存储和传递                        
**坏处是** 存在内存迁移 增加性能消耗    

装箱的内部操作: 
装箱:  根据相应的值类型在堆中分配一个值类型内存块，再将数据拷贝给它。按三步进行。
第一步: 在堆内存中新分配一个内存块(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex)。
第二步: 将值类型的实例字段拷贝到新分配的内存块中。
第三步: 返回内存堆中新分配对象的地址。这个地址就是一个指向对象的引用了。
拆箱则更为简单点，先检查对象实例，确保它是给定值类型的一个装箱值，再将该值从实例复制到值类型变量的内存块中。

**装箱、拆箱对执行效率有哪些影响，如何优化。**
由于装箱、拆箱时生成的是全新的对象，不断得分配和销毁内存会不但大量消耗CPU，也同时增加了内存碎片，降低了性能。 那该如何做呢？
最需要我们做的就是减少装箱、拆箱的操作，在我们编程规范中要牢记这种比较浪费CPU的操作，在平时编程要特别注意。
整数、浮点数、布尔等数值型变量的变化手段很少，变不出什么花样来，主要靠加强规范减少装拆箱的情况来提高性能。

**优化措施**
**Struct 通过重写函数来避免拆箱、装箱**
比如常用的ToString()，GetType()方法，如果 Struct 没有写重写ToString()和GetType()的方法，就会在 Struct 实例调用它们时先装箱再调用，导致内存块重新分配性能损耗，所以对于那些需要调用的引用方法，必须重写。
``` c#
struct Point
{
    public int X;
    public int Y;
}
class Program
{
    static void Main()
    {
        Point p = new Point { X = 1, Y = 2 };
        string str = p.ToString(); // 装箱发生
        Console.WriteLine(str); // 输出: Point
    }
}
```
ToString()、GetType()、Equals(object obj)、GetHashCode()
这些继承于Object之中的方法都需要重写 

**通过泛型来避免拆箱、装箱**
要多用泛型容器 Object
参数不确定的时候 使用泛型 而不是Object来存储 
泛型方法在编译时确定类型参数，避免了运行时装箱和拆箱操作 不使用Object方法
比如B,C继承A，就可以有这个泛型方法 void Test(T t) where T:A，以避免使用object引用类型形式传递参数。


**通过继承统一的接口提前拆箱、装箱，避免多次重复拆箱、装箱**
很多时候拆装箱不可避免，那么我们就让多种 Struct 继承某个统一的接口，不同的 Struct 就可以有相同的接口。把 Struct 传递到其他方法里去时就相当于提前进行了装箱操作，在方法中得到的是引用类型的值，并且有它需要的接口，避免了在方法中重复多次的拆装箱操作。
比如 Struct A 和 Struct B 都继承接口 I，我们调用的方法是 void Test(I i)。当调用Test方法时传进去的 Struct A 或 Struct B 的实例都相当于提前做了装箱操作，Test里拿到的参数后就不用再担心内部再次装箱拆箱问题了。
最后我依然要提醒大家 struct 值类型数据结构如果没有理解它的原理用起来可能会引起很多麻烦，切记盲目认为使用结构体会让性能提升，在没有完全彻底理解之前就冒然大量使用可能会对你的程序性能带来重创。
``` c#
// 定义一个接口
interface IExample
{
    void Print();
}

// 结构体 A 实现接口 IExample
struct A : IExample
{
    public int Value;

    public void Print()
    {
        Console.WriteLine($"A: {Value}");
    }
}

// 结构体 B 实现接口 IExample
struct B : IExample
{
    public string Name;

    public void Print()
    {
        Console.WriteLine($"B: {Name}");
    }
}
class Program
{
    // 定义一个方法，接受 IExample 接口类型的参数
    static void Test(IExample example) // 提前做了装箱操作
    {
        example.Print(); // 直接调用接口方法，无需拆箱
    }

    static void Main()
    {
        // 创建结构体实例
        A a = new A { Value = 42 };
        B b = new B { Name = "Test" };

        // 调用 Test 方法，传递结构体实例
        Test(a); // 提前装箱
        Test(b); // 提前装箱
    }
}
void TestObject(object obj)
{
    if (obj is A a)
    {
        a.Print(); // 拆箱
    }
    else if (obj is B b)
    {
        b.Print(); // 拆箱
    }
}

A a = new A { Value = 42 };
B b = new B { Name = "Test" };

TestObject(a); // 装箱
TestObject(b); // 装箱
```
### 6. C#中有哪些常用的容器类，各有什么特点
List，HashTable，Dictionary，Stack，Queue   
- Stack栈: 先进后出，入栈和出栈，底层泛型数组实现，入栈动态扩容2倍  
- Queue队列: 先进先出，入队和出队，底层泛型数组实现，表头表尾指针，判空还是满通过size比较           
Queue和Stack主要是用来存储临时信息的            

- Array数组: 需要声明长度，不安全
- ArrayList数组列表: 动态增加数组，不安全，实现了IList接口(表示可按照索引进行访问的非泛型集合对象)，Object数组实现
- List列表: 底层实现是泛型数组，特性，动态扩容，泛型安全
将泛型数据(对值类型来说就是数据本身，对引用类型来说就是引用)存储在一个泛型数组中，添加元素时若超过当前泛型数组容量，则以2倍扩容，进而实现List大小动态可变。(注: 大小指容量，不是Count)

- LinkList链表
1. 数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。
2. LinkedList(底层是由链表实现的)基于链表的数据结构，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。
3. LinkedList的优点: 插入、删除元素效率比较高；缺点: 访问效率比较低。

- HashTable哈希表(散列表)
哈希表的结构
哈希表由一个数组（称为桶数组）和哈希函数组成。
每个数组元素称为一个桶（Bucket），用于存储数据。

假设有一个大小为 10 的哈希表，哈希函数计算得到的哈希码为 23，通过取余操作 23 % 10 = 3，则将该元素放入哈希表中索引为 3 的桶中.
概念: 不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode
装填因子: α=n/m=0.72 ,存储的数据N和空间大小M
然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。
桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。
1. Key—Value形式存取，无序，类型Object，需要类型转换。
2. Hashtable查询速度快，而添加速度相对慢
3. Hashtable中的数据实际存储在内部的一个数据桶里(bucket结构体数组)，容量固定，根据数组索引获取值。

### 7.构造函数是否能被重写？
构造器Constructor不能被继承，因此不能重写，但可以被重载

### 8.C#中using的三种用法
8.1. 对命名空间的引用
引入命名空间，在使用类时可以省略复杂的前缀
``` c#
using System.Text;
global using System; //C#10新特性支持全局using，如果关键字 global 出现在 using 指令之前，则 using 适用于整个项目，即实现了项目级的统一using。
```

8.2. 2. 定义命名空间的别名
使用别名可以区分不同命名空间下相同类名的class
``` c#
using aClass = NameSpace1.MyClass; 
using bClass = NameSpace2.MyClass;
```

8.3. 自动释放所新建的对象
在定义域内的代码运行结束后，自动调用IDisposable，释放掉新建的非托管型的系统资源，
简化了try catch的写法。只有实现了IDisposable接口的类才可以使用。
``` c#
using (SqlConnection conn=new SqlConnection("Data Source=.;Initial Catalog=imageprocess;Integrated Security=True"))
{
    conn.Open();
    using(SqlCommand cmd=conn.CreateCommand())
    {
        cmd.CommandText = "select count(*) from [user]"; 
        int i = (int)cmd.ExecuteScalar();
        MessageBox.Show(i.ToString());
    }//这个括号结束的时候自动释放SqlCommand }//这个括号结束的时候自动释放SqlConnection除了using可以达到这个目的意外，try catch也是可以的。
}
```
1. 请列出C＃中几种循环的方法，并指出他们的不同？
2.  接⼝是否可继承接⼝？抽象类是否可实现(implements)接⼝？抽象类是否可继承实现类(concrete class)？
3.  ⽤双检锁实现⼀个单例模式Singleton？
11.1. 如何运作
11.2. 为什么要使用双重检查锁定？
1.  说⼀下设计模式？你都知道哪些？
2.  什么是简单⼯⼚模式？
3.  什么是强类型，什么是弱类型？哪种更好些？为什么?
4.  Set⾥的元素是不能重复的，那么⽤什么⽅法来区分重复与否呢? 是⽤==还是equals()? 它们有何区别?
5.  什么是匿名类，有什么好处？
6.  a.Equals(b)和a==b⼀样吗？
17.1. Equals与==的区别
17.2. 总结如下: 
1.  阐述什么是虚方法？它与抽象方法有什么不同？
2.  是否可以从一个static方法内部发出