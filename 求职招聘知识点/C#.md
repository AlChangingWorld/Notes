
- [一、基础部分](#一基础部分)
  - [1.值类型和引用类型有什么区别](#1值类型和引用类型有什么区别)
  - [2.重载和重写的区别](#2重载和重写的区别)
  - [3. ArrayList和 List的主要区别](#3-arraylist和-list的主要区别)
  - [4. List底层是什么实现的?](#4-list底层是什么实现的)
  - [5. LinkedList和List区别?](#5-linkedlist和list区别)
  - [6. 请描述Interface与抽象类之间的不同](#6-请描述interface与抽象类之间的不同)
  - [7. 构造函数是否能被重写?](#7-构造函数是否能被重写)
  - [8. 静态成员和⾮静态成员的区别](#8-静态成员和静态成员的区别)
  - [9.C#中ref和out关键字有什么区别?](#9c中ref和out关键字有什么区别)
  - [10.字符串中string str=null和string str=""和string str=string.Empty的区别?](#10字符串中string-strnull和string-str和string-strstringempty的区别)
  - [11.const和readonly有什么区别?](#11const和readonly有什么区别)
  - [12. 函数中多次使用string的+=处理,会产生大量内存垃圾(垃圾碎片),有什么好的方法可以解决。](#12-函数中多次使用string的处理会产生大量内存垃圾垃圾碎片有什么好的方法可以解决)
  - [13.  String s = new String(“xyz”);创建了⼏个String Object?](#13--string-s--new-stringxyz创建了个string-object)
  - [14. C#是否可以继承String类?](#14-c是否可以继承string类)
  - [15. 简述StringBuilder和String的区别?(字符串处理)](#15-简述stringbuilder和string的区别字符串处理)
  - [16.结构体和类有何区别?](#16结构体和类有何区别)
  - [17. C#两个对像值相同(x.equals(y)== true),但却可有不同的hashcode,这句话对不对?](#17-c两个对像值相同xequalsy-true但却可有不同的hashcode这句话对不对)
  - [18. ⽤最有效的⽅法算出2乘以8等于⼏?](#18-最有效的法算出2乘以8等于)
  - [19. int? 和 int有什么区别?](#19-int-和-int有什么区别)
  - [20. i++ 和 ++i 有什么区别?](#20-i-和-i-有什么区别)
  - [21. C#语言中的sleep() 和 wait() 有什么区别?](#21-c语言中的sleep-和-wait-有什么区别)
  - [22.  概述C#反射和序列?](#22--概述c反射和序列)
  - [23. C# sealed修饰符有什么特点?](#23-c-sealed修饰符有什么特点)
  - [24.数组遍历一般用for、foreach,有什么区别?](#24数组遍历一般用forforeach有什么区别)
- [中级部分](#中级部分)
  - [1. c#可否对内存直接操作](#1-c可否对内存直接操作)
  - [2. 什么是匿名⽅法?](#2-什么是匿名法)
  - [3. 什么是闭包?](#3-什么是闭包)
  - [4. CTS、CLS、CLR分别是什么?](#4-ctsclsclr分别是什么)
  - [5. 什么是装箱和拆箱?如何避免效率问题?](#5-什么是装箱和拆箱如何避免效率问题)
  - [6. C#中有哪些常用的容器类,各有什么特点](#6-c中有哪些常用的容器类各有什么特点)
  - [7.构造函数是否能被重写?](#7构造函数是否能被重写)
  - [8.C#中using的三种用法](#8c中using的三种用法)
  - [9. 请列出C＃中几种循环的方法,并指出他们的不同?](#9-请列出c中几种循环的方法并指出他们的不同)
  - [10. 接⼝是否可继承接⼝?抽象类是否可实现(implements)接⼝?抽象类是否可继承实现类(concrete class)?](#10-接是否可继承接抽象类是否可实现implements接抽象类是否可继承实现类concrete-class)
  - [11.  ⽤双检锁实现⼀个单例模式Singleton?](#11--双检锁实现个单例模式singleton)
  - [12.  说⼀下设计模式?你都知道哪些?](#12--说下设计模式你都知道哪些)
  - [13.  什么是简单⼯⼚模式?](#13--什么是简单模式)
  - [14. 什么是强类型,什么是弱类型?哪种更好些?为什么?](#14-什么是强类型什么是弱类型哪种更好些为什么)
  - [15.  Set⾥的元素是不能重复的,那么⽤什么⽅法来区分重复与否呢? 是⽤==还是equals()? 它们有何区别?](#15--set的元素是不能重复的那么什么法来区分重复与否呢-是还是equals-它们有何区别)
  - [16. 什么是匿名类,有什么好处?](#16-什么是匿名类有什么好处)
  - [17.  a.Equals(b)和a==b⼀样吗?](#17--aequalsb和ab样吗)
  - [18.  阐述什么是虚方法?它与抽象方法有什么不同?](#18--阐述什么是虚方法它与抽象方法有什么不同)
  - [19.  是否可以从一个static方法内部发出对非static方法的调用?](#19--是否可以从一个static方法内部发出对非static方法的调用)
- [高级部分](#高级部分)
  - [1. 浮点数的精度问题](#1-浮点数的精度问题)
  - [2.](#2)
  - [3. IList 接⼝与List的区别是什么?](#3-ilist-接与list的区别是什么)
  - [4. 泛型的主要约束和次要约束是什么?](#4-泛型的主要约束和次要约束是什么)
  - [5. .NET默认的委托类型有哪⼏种?](#5-net默认的委托类型有哪种)
  - [6. 结构体能实现接口吗?](#6-结构体能实现接口吗)
  - [7. 如何C#理解委托?](#7-如何c理解委托)
  - [8. 什么是event,它和delegate又有什么关系?](#8-什么是event它和delegate又有什么关系)
  - [9. 什么是泛型委托?](#9-什么是泛型委托)
  - [10. try {}⾥有⼀个return语句,那么紧跟在这个try后的finally {}⾥的code会不会被执⾏,什么时 候被执⾏,在return前还是后?](#10-try-有个return语句那么紧跟在这个try后的finally-的code会不会被执什么时-候被执在return前还是后)
  - [11. C#中 property 与 attribute的区别,他们各有什么用处,这种机制的好处在哪里?](#11-c中-property-与-attribute的区别他们各有什么用处这种机制的好处在哪里)
  - [12. 反射的实现原理?](#12-反射的实现原理)
  - [反射](#反射)
  - [13. 解释 var 和 dynamic ?](#13-解释-var-和-dynamic-)
  - [14. 如何避免类型转换时的异常?](#14-如何避免类型转换时的异常)
  - [15. Dictionary 底层原理](#15-dictionary-底层原理)
  - [16. C#的GC原理(注意这个是C#的GC,Unity的GC在这里)](#16-c的gc原理注意这个是c的gcunity的gc在这里)
- [多线程](#多线程)
  - [1. 描述线程与进程的区别?](#1-描述线程与进程的区别)
  - [2. 前台线程和后台线程有什么区别?](#2-前台线程和后台线程有什么区别)
  - [3.Task状态机的实现和⼯作机制是什么？](#3task状态机的实现和作机制是什么)
  - [4.await的作⽤和原理，并说明和GetResult()有什么区别\*\*？](#4await的作和原理并说明和getresult有什么区别)
  - [5. Task和Thread有区别吗？](#5-task和thread有区别吗)
  - [6. 线程池的有点和不⾜?](#6-线程池的有点和不)
  - [7. Mutex和lock有什么不同？⼀般⽤哪⼀种⽐较好？](#7-mutex和lock有什么不同般哪种较好)

## 一、基础部分

### 1.值类型和引用类型有什么区别
**值类型** 包括所有的数值类型 struct 枚举       
**引用类型** 类 数组 接口 string delegate 

- 存储空间不同
值类型是存储在栈中 内存是自动释放的
引用类型存储在堆中  内存需要GC来释放 

- 值类型 存取速度块, 引用类型慢

- 值类型代表的是实际数据, 引用类型代表 在栈中存储在堆中的地址 在堆中存储真正的数据
类中 值类型成员也在堆中,而引用类型成员数据类型也会在堆里 引用在类数据部分中

- 值类型在赋值时把内容拷贝给了对方 他变我不变, 引用类型在赋值时 让俩者指向了同一内存地址 他变我也变

- 引用类型继承于万物之父Object, 值类型继承于System.ValueType


### 2.重载和重写的区别
重载 是指函数重载 参数类型、数量、顺序的不同调用不同的函数          
重写是override 在父类和子类中使用这个方法时 调用的是重写过的方法            

- 封装、继承、多态所处位置不同,重载在同类中,重写在父子类中。          
- 定义方式不同,重载方法名相同参数列表不同,重写方法名和参数列表都相同。                
- 调用方式不同,重载使用相同对象以不同参数调用,重写用不同对象以相同参数调用。              
- 多态时机不同,重载时编译时多态,重写是运行时多态。


### 3. ArrayList和 List的主要区别           
- ArrayList 不带泛型 数据类型丢失 存储的是Object类型存在装箱拆箱 操作费时
List 带泛型 数据类型不丢失 List是泛型方法 不存在装箱拆箱的问题          

- ArrayList存在不安全类型(ArrayList会把所有插⼊其中的数据都当做Object来处理)装箱拆箱的 操作(费时)               
- IList是接⼝,ArrayList是⼀个实现了该接⼝的类,可以被实例化              
- List类是ArrayList类的泛型等效类。它的大部分用法都与ArrayList相似,因为List类也继承了IList接口。最关键的区别在于,在声明List集合时,我们同时需要为其声明List集合内数据的对象类型。             

     


### 4. List底层是什么实现的?
List它的底层实现是使用数组。List类中的元素可以通过索引来访问,并且在索引越界时会抛出异常。
当你对List中的元素进行增加操作时,List会自动重新分配内存以适应变化后的大小。List底层的数组会在元素数量不够时扩容。所以最好是一开始就初始化好数量,而不是一个一个add进去。

List底层有一个自动扩容 刚开始16 后面32会翻倍的往上加
所以不需要这事先确定容量大小
具体扩容: 当向列表中添加元素并且列表的容量不足以容纳新元素时,List<T> 会进行扩容。扩容操作通常会将数组的大小增加一倍(尽管这不是固定的,并且可能因实现而异),并将现有元素复制到新的数组中。扩容操作的时间复杂度是 O(n),但由于它只在需要时发生,因此平均下来对性能的影响较小。

### 5. LinkedList和List区别?
List是一个基于数组的数据结构,可以随机访问列表中的任何元素。当需要添加或删除元素时,List需要重新分配内存空间,因此插入或删除操作可能会导致性能下降。List适用于需要随机访问元素的场景,例如需要按索引进行访问或排序等操作。查改出色

LinkedList是一个基于链表的数据结构,双向链表, 它不支持随机访问元素。要访问列表中的任何元素,必须从头节点开始遍历整个列表。但是,插入或删除元素时,LinkedList只需要调整节点指针,因此插入或删除操作的性能通常比List更高。LinkedList适用于需要频繁插入或删除元素的场景

### 6. 请描述Interface与抽象类之间的不同
1. 接口不是类 不能实例化 抽象类可以间接实例化 可以通过实例化子类对象来调用抽象类中的方法 
2. 接口是完全抽象 方法可以实现不过能覆盖 抽象类为部分抽象 在抽象类中 可以当正常类来写 只不过不能实例化
3. 接口可以多继承 抽象类是单继承
4. 接口中可以有静态成员 方法、属性、事件和索引器

### 7. 构造函数是否能被重写?
不能 但是可以重载 构造器Constructor不能被继承


### 8. 静态成员和⾮静态成员的区别
- 静态成员 ⽤statis修饰符声明 存储在静态区里 可以通过类名.的形式获取 全局都是一个 类被第一次加载到内存时创建
- 非静态成员在对象被实例化时创建 只能通过实例化来获取
- 静态⽅法⾥不能使⽤⾮静态成员,⾮静态⽅法可以使⽤静态成员 

### 9.C#中ref和out关键字有什么区别?

- ref修饰引用参数。参数必须赋值,带回返回值,又进又出 传入的值必须初始化
- out修饰输出参数。参数可以不赋值,带回返回值之前必须明确赋值,传入的每一个输出参数必须在内部赋值
- 引用参数和输出参数不会创建新的存储位置
- 如果ref参数是值类型,原先的值类型数据,会随着方法里的数据改变而改变,
- 如果ref参数值引用类型,方法里重新赋值后,原对象堆中数据会改变,如果对引用类型再次创建新对象并赋值给ref参数,引用地址会重新指向新对象堆数据。
```c#
int i;
changeRef(ref i);   // 报错
changeOut(out i);   // 不报错 但是必须在函数中赋值
```

### 10.字符串中string str=null和string str=""和string str=string.Empty的区别?
- string.Empty相当于“”,Empty是⼀个静态只读的字段。 
- string str="" ,初始化对象,并分配⼀个空字符串的内存空间 
- string str=null,初始化对象,不会分配内存空间


### 11.const和readonly有什么区别?          
都可以标识⼀个常量。必须初始化 不能被修改       
主要有以下区别:                 
1. 初始化位置不同。const必须在声明的同时赋值；readonly即可以在声明处赋值,也可以构造⽅法⾥赋值。        
2. const是编译时常量,在编译时确定该值；readonly是运⾏时常量,在运⾏时确定该值。        
3. const默认是静态的；⽽readonly如果设置成静态需要显示声明 static       
4. 修饰引⽤类型时不同,const只能修饰 值类型和string或值为null的其他引⽤类型；readonly可以是任何类型。        


### 12. 函数中多次使用string的+=处理,会产生大量内存垃圾(垃圾碎片),有什么好的方法可以解决。
string是个特殊的引用类型 每一次重新赋值或者拼接会分配新的内存空间
通过StringBuilder 需要频繁修改和拼接的字符串 那进行append,这样可以减少内存垃圾 在最开始 给定容量 超过会扩容乘2


### 13.  String s = new String(“xyz”);创建了⼏个String Object?
两个对象,⼀个是“xyz”,⼀个是指向“xyz”的引⽤对象s.
当使用 new string("xyz"); 时,会在堆上创建一个新的 string 对象

“xyz” 存在于了字符串驻留池
字符串驻留池的核心概念是确保具有相同值的字符串在内存中只有一个实例。        
工作原理如下
当你在代码中使用字符串字面值时, 编译器会将这些字符串字面值存储在字符串驻留池中。这是编译时的操作 不是运行时操作。           
2.检查字符串值:在创建字符串字面值时,编译器会首先检査字符串池,看是否已经存在具有相同值的字符串。如果存在,编译器会返回对现有字符串的引用,而不是创建-个新的字符串对象,

### 14. C#是否可以继承String类?
不能,类似于sealed修饰过,String在.Net里有特殊处理过。

### 15. 简述StringBuilder和String的区别?(字符串处理)
String是字符串常量,线程安全。
StringBuilder是字符串变量,线程不安全。
- String类型是个不可变的对象,当每次对String进⾏改变时都需要⽣成⼀个新的String对象,然后将指针指向⼀个新的对象,如果在⼀个循环⾥⾯,不断的改变⼀个对象,就要不断的⽣成新的对象,所以效率很低,建议在不断更改String对象的地⽅不要使⽤String类型。
- StringBuilder对象在做字符串连接操作时是在原来的字符串上进⾏修改,改善了性能。同一块内存地址 这⼀点我们平时使⽤中也许都知道,连接操作频繁的时候,使⽤StringBuilder对象。方法少一些

string线程安全。由于是不可变的,每次修改都会创建新对象,因此在多线程环境中,sting是线程安全的,因为多个线程读取同-string对象不会发生冲突,不需要额外的同步机制。你用你的 我用我的

在多线程环境下,StringBuilder 不保证线程安全。这是因为 StringBuilder 的方法没有进行同步处理,当多个线程同时对同一个 StringBuilder 对象进行操作时,可能会出现数据不一致的情况。例如,一个线程正在执行 append 操作,而另一个线程同时执行 delete 操作

### 16.结构体和类有何区别?

- 结构体是值类型,存储在栈上 类是引用类型,存储在堆上
- 结构体不能够继承 类可以继承
- 结构体不能声明析构函数 类可以
- 结构体不能是静态结构体 静态类可以
- 结构体也能使用接口
结构体的属性和字段可以能初始化 但是需要一个public的构造函数

### 17. C#两个对像值相同(x.equals(y)== true),但却可有不同的hashcode,这句话对不对?
不对,有相同的hashcode。
(1) 如果两个对象相同(equals方法返回true),那么它们的hashCode值一定要相同；
(2) 如果两个对象的hashCode相同,它们并不一定相同。因为存在哈希冲突
哈希码的目的是为了优化性能,而不是唯一标识对象。因此: 

如果两个对象的值不同(x.Equals(y) == false),它们的哈希码可以相同,也可以不同。
哈希码相同并不会影响程序的正确性,只是可能会导致哈希冲突,稍微降低性能。
字符串 "Aa" 和 "BB" 的哈希码计算结果是相同的(哈希冲突)
Dictionary、HashSet 用的都是底层哈希码
快速定位: 通过哈希码直接定位到存储位置,避免遍历整个数据集。
减少比较次数: 只需要在同一个“桶”中的少量对象中进行比较。
理想时间复杂度: 从 O(n) 降低到 O(1)。

### 18. ⽤最有效的⽅法算出2乘以8等于⼏? 
位运算是最快,使⽤的是位运算 逻辑左位移<<。 ⽅法是2<<3 相当于0000 0000 0000 0010 (2的16位int⼆进制) 2的3次方 左移三位就是 0000 0000 0001 0000 (16的⼆进制)

### 19. int? 和 int有什么区别?

int?为可空类型, Nullable<int>是个结构体, 默认值可以是null 
安全获取可空类型 如果为空 返回默认值 int默认值是0 

可以帮助我们自动判断o是否为空 比如事件的invoke的时候

### 20. i++ 和 ++i 有什么区别?
i++ 是先赋值,再⾃增；++i 是先⾃增,再赋值。

### 21. C#语言中的sleep() 和 wait() 有什么区别?
sleep()方法是将当前线程挂起指定的时间。线程的休眠 1000毫秒 = 1秒 
wait()释放对象上的锁并阻塞当前线程,直到它重新获取该锁

### 22.  概述C#反射和序列?
反射: 公共语言运行库加载器管理应用程序域。这种管理包括将每个程序集加载到相应的应用程序域以及控制每个程序集中类型层次结构的内存布局。程序集包含模块,而模块包含类型,类型又包含成员。反射则提供了封装程序集、模块和类型的对象。您可以使用反射动态地创建类型的实例,将类型绑定到现有对象,或从现有对象中获取类型。然后,可以调用类型的方法或访问其字段和属性。

序列化: 序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化,它将流转换为对象。这两个过程结合起来,可以轻松地存储和传输数据

### 23. C# sealed修饰符有什么特点?
sealed 修饰符表示密封
用法: 
1.用于类时,表示该类不能再被继承,不能和abstract同时使用,因为这两个修饰符在含义上互相排斥

2.用于方法和属性时,表示该方法或属性不能再被重写,必须和override关键字一起使用,因为使用sealed修饰符的方法和属性肯定是基类中相应的虚成员。
让虚方法或者抽象方法之后不能再被重写.
常见用处: 
1.通常在实现第三方类库时不想被客户端继承,或用于没有必要再继承的类以防止滥用继承造成层次结构体系混乱。
2.恰当的利用sealed修饰符也可以提高一定的运行效率,因为不用考虑继承类会重写该成员。

### 24.数组遍历一般用for、foreach,有什么区别?
可以用**foreach**遍历的类 都是实现了迭代器的   
foreach也称为只读循环,所以在循环数组/集合的时候,无法对数组/集合进行修改 
因为是复制的副本索引 对于值类型不能修改。引用类型可以修改对象的属性

给定长度 不需要计算长度的 for比foreach循环效率高,在不确定长度 或者计算长度有性能损耗的时候 用foreach比较方便。foreach循环的时候会释放使用完的资源,所以会造成额外的gc开销

## 中级部分
### 1. c#可否对内存直接操作
C#在unsafe 模式下可以使⽤指针对内存进⾏操作, 但在托管模式下不可以使⽤指针,C#NET默认不运⾏带指针的,需要设置下,选择项⽬右键->属性->选择⽣成->“允许不安全代码”打勾->保存
``` c#
unsafe
{
    int value = 42;
    int* pointer = &value; // 获取 value 的地址
    *pointer = 100; // 直接修改内存中的值
    Console.WriteLine(value); // 输出: 100
}
``` 
### 2. 什么是匿名⽅法?
匿名⽅法是⽤作委托的参数的⼀段代码。
``` c#
Func<int, int> anon = delegate(int i) 
{ 
 i = i+1; 
 return i; 
}; 
//输出2 
Console.WriteLine(anon(1)); 
//匿名⽅法,例2 
Action<int> anon2 = delegate(int i) 
{ 
 i = i + 1; 
}; 
//输出2 
Console.WriteLine(anon(1));
```

### 3. 什么是闭包?
通过Lambda表达式可以访问Lambda表达式块外部的变量,这成为闭包。 
当引⽤外部变量时,需要注意,外部变量变化时,lambda表达式的结果也可能会随着外部变量变化⽽变 
化。 
**内层的函数可以引用包含在它外层函数的变量**        
**即使外层函数的执行已经终止**       
**临时变量进入委托和事件后生命周期会改变**   
**在闭包情况下临时变量不会被释放**
**该变量提供的值并非变量创建时的值 而是在父函数范围内的最终值**    

### 4. CTS、CLS、CLR分别是什么?
CTS: 通⽤语⾔系统。CLS: 通⽤语⾔规范。CLR: 公共语⾔运⾏库。 
CTS: Common Type System 通⽤类型系统。Int32、Int16→int、String→string、Boolean→bool。 
每种语⾔都定义了⾃⼰的类型,.Net通过CTS提供了公共的类型,然后翻译⽣成对应的.Net类型。 
CLS: Common Language Specification 通⽤语⾔规范。不同语⾔语法的不同。每种语⾔都有⾃⼰的 
语法,.Net通过CLS提供了公共的语法,然后不同语⾔翻译⽣成对应的.Net语法。 
CLR: Common Language Runtime 公共语⾔运⾏时,就是GC、JIT等这些。有不同的CLR,⽐如服务 
器CLR、Linux CLR(Mono)、Silverlight CLR(CoreCLR)。相当于⼀个发动机,负责执⾏IL。

### 5. 什么是装箱和拆箱?如何避免效率问题?
**装箱拆箱问题** 

**装箱**----object存值类型      
把值类型用引用类型存储  把值类型实例转换为引用类型实例    
栈内存会迁移到堆内存中          
``` c#      
Object i = 12; //栈中存放堆地址 堆中存放12      
```  

**拆箱**----拿出来使用 objcet转为值类型 拆箱是显示转换      
把引用类型存储的值类型取出来   把引用类型实例转换为值类型实例     
堆内存会迁移到栈内存中          
``` c#
object v=3;                 
int intValue = (int)v;  //使用需要强制转换
``` 
**好处是** 不确定类型时可以方便参数的存储和传递                        
**坏处是** 存在内存迁移 增加性能消耗    

装箱的内部操作: 
装箱:  根据相应的值类型在堆中分配一个值类型内存块,再将数据拷贝给它。按三步进行。
第一步: 在堆内存中新分配一个内存块(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex)。
第二步: 将值类型的实例字段拷贝到新分配的内存块中。
第三步: 返回内存堆中新分配对象的地址。这个地址就是一个指向对象的引用了。
拆箱则更为简单点,先检查对象实例,确保它是给定值类型的一个装箱值,再将该值从实例复制到值类型变量的内存块中。

**装箱、拆箱对执行效率有哪些影响,如何优化。**
由于装箱、拆箱时生成的是全新的对象,不断得分配和销毁内存会不但大量消耗CPU,也同时增加了内存碎片,降低了性能。 那该如何做呢?
最需要我们做的就是减少装箱、拆箱的操作,在我们编程规范中要牢记这种比较浪费CPU的操作,在平时编程要特别注意。
整数、浮点数、布尔等数值型变量的变化手段很少,变不出什么花样来,主要靠加强规范减少装拆箱的情况来提高性能。

**优化措施**
**Struct 通过重写函数来避免拆箱、装箱**
比如常用的ToString(),GetType()方法,如果 Struct 没有写重写ToString()和GetType()的方法,就会在 Struct 实例调用它们时先装箱再调用,导致内存块重新分配性能损耗,所以对于那些需要调用的引用方法,必须重写。
``` c#
struct Point
{
    public int X;
    public int Y;
}
class Program
{
    static void Main()
    {
        Point p = new Point { X = 1, Y = 2 };
        string str = p.ToString(); // 装箱发生
        Console.WriteLine(str); // 输出: Point
    }
}
```
ToString()、GetType()、Equals(object obj)、GetHashCode()
这些继承于Object之中的方法都需要重写 

**通过泛型来避免拆箱、装箱**
要多用泛型容器 Object
参数不确定的时候 使用泛型 而不是Object来存储 
泛型方法在编译时确定类型参数,避免了运行时装箱和拆箱操作 不使用Object方法
比如B,C继承A,就可以有这个泛型方法 void Test(T t) where T:A,以避免使用object引用类型形式传递参数。


**通过继承统一的接口提前拆箱、装箱,避免多次重复拆箱、装箱**
很多时候拆装箱不可避免,那么我们就让多种 Struct 继承某个统一的接口,不同的 Struct 就可以有相同的接口。把 Struct 传递到其他方法里去时就相当于提前进行了装箱操作,在方法中得到的是引用类型的值,并且有它需要的接口,避免了在方法中重复多次的拆装箱操作。
比如 Struct A 和 Struct B 都继承接口 I,我们调用的方法是 void Test(I i)。当调用Test方法时传进去的 Struct A 或 Struct B 的实例都相当于提前做了装箱操作,Test里拿到的参数后就不用再担心内部再次装箱拆箱问题了。
最后我依然要提醒大家 struct 值类型数据结构如果没有理解它的原理用起来可能会引起很多麻烦,切记盲目认为使用结构体会让性能提升,在没有完全彻底理解之前就冒然大量使用可能会对你的程序性能带来重创。
``` c#
// 定义一个接口
interface IExample
{
    void Print();
}

// 结构体 A 实现接口 IExample
struct A : IExample
{
    public int Value;

    public void Print()
    {
        Console.WriteLine($"A: {Value}");
    }
}

// 结构体 B 实现接口 IExample
struct B : IExample
{
    public string Name;

    public void Print()
    {
        Console.WriteLine($"B: {Name}");
    }
}
class Program
{
    // 定义一个方法,接受 IExample 接口类型的参数
    static void Test(IExample example) // 提前做了装箱操作
    {
        example.Print(); // 直接调用接口方法,无需拆箱
    }

    static void Main()
    {
        // 创建结构体实例
        A a = new A { Value = 42 };
        B b = new B { Name = "Test" };

        // 调用 Test 方法,传递结构体实例
        Test(a); // 提前装箱
        Test(b); // 提前装箱
    }
}
void TestObject(object obj)
{
    if (obj is A a)
    {
        a.Print(); // 拆箱
    }
    else if (obj is B b)
    {
        b.Print(); // 拆箱
    }
}

A a = new A { Value = 42 };
B b = new B { Name = "Test" };

TestObject(a); // 装箱
TestObject(b); // 装箱
```
### 6. C#中有哪些常用的容器类,各有什么特点
List,HashTable,Dictionary,Stack,Queue   
- Stack栈: 先进后出,入栈和出栈,底层泛型数组实现,入栈动态扩容2倍  
- Queue队列: 先进先出,入队和出队,底层泛型数组实现,表头表尾指针,判空还是满通过size比较           
Queue和Stack主要是用来存储临时信息的            

- Array数组: 需要声明长度,不安全
- ArrayList数组列表: 动态增加数组,不安全,实现了IList接口(表示可按照索引进行访问的非泛型集合对象),Object数组实现
- List列表: 底层实现是泛型数组,特性,动态扩容,泛型安全
将泛型数据(对值类型来说就是数据本身,对引用类型来说就是引用)存储在一个泛型数组中,添加元素时若超过当前泛型数组容量,则以2倍扩容,进而实现List大小动态可变。(注: 大小指容量,不是Count)

- LinkList链表
1. 数组和List、ArrayList集合都有一个重大的缺陷,就是从数组的中间位置删除或插入一个元素需要付出很大的代价,其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。
2. LinkedList(底层是由链表实现的)基于链表的数据结构,很好的解决了数组删除插入效率低的问题,且不用动态的扩充数组的长度。
3. LinkedList的优点: 插入、删除元素效率比较高；缺点: 访问效率比较低。

- HashTable哈希表(散列表)
哈希表的结构
哈希表由一个数组(称为桶数组)和哈希函数组成。
每个数组元素称为一个桶(Bucket),用于存储数据。

假设有一个大小为 10 的哈希表,哈希函数计算得到的哈希码为 23,通过取余操作 23 % 10 = 3,则将该元素放入哈希表中索引为 3 的桶中.
概念: 不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集,即Key通过HashFunction函数获得HashCode
装填因子: α=n/m=0.72 ,存储的数据N和空间大小M
然后通过哈希桶算法,HashCode分段,每一段都是一个桶结构,一般是HashCode直接取余。
桶结构会加剧冲突,解决冲突使用拉链法,将产生冲突的元素建立一个单链表,并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。
1. Key—Value形式存取,无序,类型Object,需要类型转换。
2. Hashtable查询速度快,而添加速度相对慢
3. Hashtable中的数据实际存储在内部的一个数据桶里(bucket结构体数组),容量固定,根据数组索引获取值。

### 7.构造函数是否能被重写?
构造器Constructor不能被继承,因此不能重写,但可以被重载

### 8.C#中using的三种用法
8.1. 对命名空间的引用
引入命名空间,在使用类时可以省略复杂的前缀
``` c#
using System.Text;
global using System; //C#10新特性支持全局using,如果关键字 global 出现在 using 指令之前,则 using 适用于整个项目,即实现了项目级的统一using。
```

8.2. 2. 定义命名空间的别名
使用别名可以区分不同命名空间下相同类名的class
``` c#
using aClass = NameSpace1.MyClass; 
using bClass = NameSpace2.MyClass;
```

8.3. 自动释放所新建的对象
在定义域内的代码运行结束后,自动调用IDisposable,释放掉新建的非托管型的系统资源,
简化了try catch的写法。只有实现了IDisposable接口的类才可以使用。
``` c#
using (SqlConnection conn=new SqlConnection("Data Source=.;Initial Catalog=imageprocess;Integrated Security=True"))
{
    conn.Open();
    using(SqlCommand cmd=conn.CreateCommand())
    {
        cmd.CommandText = "select count(*) from [user]"; 
        int i = (int)cmd.ExecuteScalar();
        MessageBox.Show(i.ToString());
    }//这个括号结束的时候自动释放SqlCommand }//这个括号结束的时候自动释放SqlConnection除了using可以达到这个目的意外,try catch也是可以的。
}
```

### 9. 请列出C＃中几种循环的方法,并指出他们的不同?
For :使用于确定次数的循环
Foreach:使用于遍历的元素 只读
Do…while: 次数不确定条件随机变化但至少要保证能被执行一次
While:次数不确定 条件随机 变化

### 10. 接⼝是否可继承接⼝?抽象类是否可实现(implements)接⼝?抽象类是否可继承实现类(concrete class)?
接⼝可以继承接⼝,抽象类可以实现接⼝,抽象类可以继承实现类,但前提是实现类必须有明确的构造函数。            
在面向对象编程中,当一个类继承另一个类时,派生类(子类)的实例化过程会隐式调用基类(父类)的构造函数。如果基类没有可访问的构造函数,派生类将无法正确初始化基类的部分,从而导致编译错误。
父类显式定义了构造函数覆盖了默认的无参构造 必须通过 base(value) 显式调用基类的构造函数

### 11.  ⽤双检锁实现⼀个单例模式Singleton?
``` c#
public class Singleton
{
    private static Singleton _instance;
    private static readonly object _lock = new object(); //锁
 
    private Singleton() {}
 
    public static Singleton Instance
    {
        get
        {
            if (_instance == null)
            {
                lock (_lock)
                {
                    if (_instance == null)
                    {
                        _instance = new Singleton();
                    }
                }
            }
            return _instance;
        }
    }
}
```
11.1. **如何运作**          
● First Null Check：第一次检查, 在获取锁之前,代码会检查实例是否已创建。如果不是,则输入锁定块。
● Locking：如果尚未创建实例,则代码会锁定critical部分,以确保没有其他线程可以同时创建实例。
● 第二次空检查：获取锁后,它会再次检查实例是否仍为null。这是必要的,以避免多个线程可能通过第一次检查并尝试同时创建实例的竞争条件。

**为什么要第二次检查**
假设线程 A 和线程 B 同时通过了第一次检查(_instance == null)。
线程 A 先获取锁,进入临界区并创建了 Singleton 实例。
线程 A 释放锁后,线程 B 获取锁并进入临界区。
如果没有第二次检查,线程 B 会再次创建 Singleton 实例,从而导致单例模式被破坏。

11.2. **为什么要使用双重检查锁定?**            
双重检查锁定可确保Singleton实例是延迟初始化和线程安全的,并特别注重性能优化。以下是此方法很重要的原因：
1. **延迟初始化**：仅在首次需要时创建单例实例,而不是在应用程序开始时创建,从而节省资源并可能避免不必要的数据库连接或对象创建。
2. **减少锁定开销**：如果没有双重检查锁定,则每次访问Instance属性时都会执行该lock语句,即使在已创建Singleton实例之后也是如此。这种常量锁定会带来不必要的开销,尤其是在经常访问单例的高性能或多线程环境中。                  
使用双重检查锁定时,该方法首先检查实例是否已创建,而无需获取锁定(第一次null检查)。如果实例存在,它将完全跳过锁,从而显著提高Singleton已初始化的常见情况下的性能。         
3. **Thread-Safety**：在第一次访问期间,如果Singleton尚未创建,则锁确保只有一个线程初始化实例。初始化后,后续线程将绕过锁,从而避免在将来的访问中降低性能。
4. 避免争用条件：通过使用两项检查,您可以确保一旦线程位于lock块内,它会在创建实例之前重新检查实例的状态,从而防止多个线程同时创建不同的实例。

第一次检查：快速判断实例是否已存在,避免不必要的加锁。在单例实例已经创建后,访问 Instance 属性的性能几乎和无锁操作一样高.
加锁：确保只有一个线程可以创建实例。
第二次检查：防止多个线程重复创建实例。

11.3.**饿汉单例模式**
在类加载时就立即初始化实例 线程安全,但如果单例类实例占用资源较多且未被使用,会造成资源浪费。
``` c#
private static readonly Singleton instance = new Singleton();
```
11.3.**懒汉单例模式**
实例在第一次访问时才会被创建, 非线程安全,如果在多线程环境下使用需要额外处理同步问题.
``` c#
private static readonly Singleton instance = new Singleton();
```

### 12.  说⼀下设计模式?你都知道哪些?
设计模式总共有 23 种,总体来说可以分为三⼤类：创建型模式( Creational Patterns )、结构型模 
式( Structural Patterns )和⾏为型模式( Behavioral Patterns )。 
创建型模式： 
⼯⼚模式、抽象⼯⼚模式、**单例模式**、建造者模式、原型模式 关注于对象的创建,同时隐藏创建逻辑 
结构型模式： 
适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式 关注类和 
对象之间的组合 
⾏为型模式： 责任链模式、命令模式、中介者模式、**观察者模式**、状态模式、策略模式、模板模式、空 
对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式 关注对象之间的通信


### 13.  什么是简单⼯⼚模式?           
简单⼯⼚模式⼜叫静态⼯⼚⽅法模式,就是建⽴⼀个⼯⼚类,对实现了同⼀接⼝的⼀些类进⾏实例的创 
建。⽐如,⼀台咖啡机就可以理解为⼀个⼯⼚模式,你只需要按下想喝的咖啡品类的按钮(摩卡或拿 
铁),它就会给你⽣产⼀杯相应的咖啡,你不需要管它内部的具体实现,只要告诉它你的需求即可。 
优点：                                     
⼯⼚类含有必要的判断逻辑,可以决定在什么时候创建哪⼀个产品类的实例,客户端可以免除直接创建 
产品对象的责任,⽽仅仅“消费”产品；简单⼯⼚模式通过这种做法实现了对责任的分割,它提供了专⻔ 
的⼯⼚类⽤于创建对象；                                    
客户端⽆须知道所创建的具体产品类的类名,只需要知道具体产品类所对应的参数即可,对于⼀些复杂 
的类名,通过简单⼯⼚模式可以减少使⽤者的记忆量；                        
通过引⼊配置⽂件,可以在不修改任何客户端代码的情况下更换和增加新的具体产品类,在⼀定程度上 
提⾼了系统的灵活性。     

**缺点：**                                             
不易拓展,⼀旦添加新的产品类型,就不得不修改⼯⼚的创建逻辑；                 
产品类型较多时,⼯⼚的创建逻辑可能过于复杂,⼀旦出错可能造成所有产品的创建失败,不利于系统 
的维护。            
代码实现：      

抽象敌人类 Enemy：继承自 MonoBehaviour,是所有具体敌人类的基类,定义了一个抽象方法 Attack。
具体敌人类 MeleeEnemy 和 RangedEnemy：继承自 Enemy,实现了 Attack 方法。
敌人工厂类 EnemyFactory：包含一个静态方法 CreateEnemy,根据传入的 EnemyType 枚举值创建不同类型的敌人对象,并设置其位置。
测试脚本 FactoryTest：在 Start 方法中调用 EnemyFactory 的 CreateEnemy 方法创建不同类型的敌人,并调用其 Attack 方法。

可以方便地创建不同类型的游戏对象和资源,同时将创建逻辑封装在工厂类中,使代码更加清晰和易于维护

``` c#
using UnityEngine;

// 抽象敌人类
public abstract class Enemy : MonoBehaviour
{
    public abstract void Attack();
}

// 近战敌人类
public class MeleeEnemy : Enemy
{
    public override void Attack()
    {
        Debug.Log("近战敌人进行攻击");
    }
}

// 远程敌人类
public class RangedEnemy : Enemy
{
    public override void Attack()
    {
        Debug.Log("远程敌人进行攻击");
    }
}

// 敌人工厂类
public class EnemyFactory
{
    public static Enemy CreateEnemy(EnemyType enemyType, Vector3 position)
    {
        GameObject enemyGameObject;
        Enemy enemy;

        switch (enemyType)
        {
            case EnemyType.Melee:
                enemyGameObject = new GameObject("MeleeEnemy");
                enemy = enemyGameObject.AddComponent<MeleeEnemy>();
                break;
            case EnemyType.Ranged:
                enemyGameObject = new GameObject("RangedEnemy");
                enemy = enemyGameObject.AddComponent<RangedEnemy>();
                break;
            default:
                throw new System.ArgumentException("无效的敌人类型");
        }

        enemyGameObject.transform.position = position;
        return enemy;
    }
}

// 敌人类型枚举
public enum EnemyType
{
    Melee,
    Ranged
}

// 测试脚本
public class FactoryTest : MonoBehaviour
{
    void Start()
    {
        // 创建近战敌人
        Enemy meleeEnemy = EnemyFactory.CreateEnemy(EnemyType.Melee, Vector3.zero);
        meleeEnemy.Attack();

        // 创建远程敌人
        Enemy rangedEnemy = EnemyFactory.CreateEnemy(EnemyType.Ranged, new Vector3(2, 0, 0));
        rangedEnemy.Attack();
    }
}
```    
### 14. 什么是强类型,什么是弱类型?哪种更好些?为什么?     
强类型是在编译的时候就确定类型的数据,在执⾏时类型不能更改,⽽弱类型在执⾏的时候才会确定类          
型。没有好不好,⼆者各有好处,
强类型安全,强类型语言在编译时就确定了变量的类型,并且在运行时类型不能更改。变量的类型是固定的,必须显式声明或通过上下文推断因为它事先已经确定好了,⽽且效率⾼。⼀般⽤于编译型编程语⾔,如c++,java,c#,pascal等,
安全性高：编译器会捕获类型错误,减少运行时错误。
性能好：类型在编译时确定,运行时效率高。
``` c#
int number = 10; // 声明一个整数类型的变量
number = "Hello"; // 编译错误：不能将字符串赋值给整数类型
```         

**弱类型**相⽐⽽⾔不安全,弱类型语言在运行时才确定变量的类型,变量的类型可以动态改变                 
在运⾏的时候容易出现错误,但它灵活,多⽤于解释型编程语⾔,如lua等                                        
动态类型：变量的类型在运行时确定,不需要显式声明。              
类型转换：Lua 会自动进行一些类型转换,例如字符串和数字之间的转换。                      
灵活性：同一个变量可以在不同的上下文中存储不同类型的值。                
由于 Lua 是弱类型语言,它的类型安全性较低,错误通常只能在运行时被发现。       
``` lua
local value = "Hello"
value = value + 10  -- 运行时错误: 尝试将字符串与数字相加
```

**编译型语言特性**      
C# 是一种编译型语言。在使用 C# 开发游戏或应用程序时,编写好的 C# 代码需要经过编译器的编译,将高级的 C# 代码转换为计算机能够理解的机器码或者中间语言(如.NET 平台的中间语言 MSIL)。编译过程会生成可执行文件或者程序集(如 .exe、.dll 文件)。                    
**热更新困难的原因**                  
当游戏发布后,玩家运行的是编译好的二进制文件。如果要修改 C# 代码实现的功能,就需要重新编译代码并生成新的可执行文件或程序集,然后让玩家下载安装新的版本。这是因为编译后的代码结构和逻辑已经被固化在二进制文件中,无法在游戏运行时直接修改。而且在很多情况下,重新编译可能会引入新的问题,还需要进行全面的测试,这使得更新成本较高、周期较长。    

**Lua 脚本特性与热更新优势**                    
解释型语言特性              
Lua 是一种解释型语言,它的代码是以文本脚本的形式存在的。在游戏运行时,Lua 解释器会逐行读取并执行 Lua 脚本代码。这意味着 Lua 代码不需要提前编译成二进制文件,而是在运行时动态解释执行。              
热更新实现原理              
由于 Lua 代码是在运行时解释执行的,所以可以在游戏运行过程中动态加载和替换 Lua 脚本文件。当需要更新游戏的某些功能时,开发者只需要修改相应的 Lua 脚本,然后通过网络将新的脚本文件传输到玩家的设备上,游戏就可以在不重启的情况下加载并执行新的脚本代码,实现热更新。例如,在游戏中修改一个角色的技能逻辑,只需要更新对应的 Lua 脚本文件,玩家再次触发该技能时就会使用新的逻辑。            

**结合使用的常见模式**                               
在实际的游戏开发中,很多项目会采用 C# 和 Lua 结合的方式。C# 通常用于实现游戏的底层框架、性能关键部分和与系统交互的功能,而 Lua 用于实现游戏的业务逻辑、脚本化内容等。这样既可以利用 C# 的高性能和强大的功能,又可以借助 Lua 的灵活性实现热更新。            
综上所述,C# 编译后的内容相对固定,而 Lua 由于其运行时解释执行的特性,可以方便地在玩家运行游戏时进行代码更新。                  

### 15.  Set⾥的元素是不能重复的,那么⽤什么⽅法来区分重复与否呢? 是⽤==还是equals()? 它们有何区别?    
先计算元素的哈希码GetHashCode,然后与已有元素的哈希码进行比较. 如果哈希码相同,考虑哈希冲突问题,HashSet 会调用元素类型的 Equals() 方法来进一步比较元素是否相等。如果哈希码不同,则 HashSet 会认为元素不重复。

Set⾥的元素是不能重复的,那么⽤iterator()⽅法来区分重复与否。equals()是判读两个Set是否相等。              
equals()和==⽅法决定引⽤值是否指向同⼀对像,equals()在类中被覆盖,为的是当两个分离的对象的        
内容和类型相配的话,返回真值。       

**== 运算符**
== 运算符用于比较两个对象的引用是否相等(对于引用类型),或者比较两个值是否相等(对于值类型)。具体如下：
引用类型：比较的是两个引用是否指向同一个对象实例地址。

**Equals() 方法**
Equals() 方法用于比较两个对象的内容是否相等。它可以被重写以实现自定义的相等比较逻辑。
默认行为：对于引用类型,默认情况下 Equals() 方法和 == 运算符一样,比较的是引用是否相等; 对于值类型,比较的是值是否相等。

### 16. 什么是匿名类,有什么好处?
不⽤定义、没有名字的类,使⽤⼀次便可丢弃。好处是简单、随意、临时的。
``` c#
var v = new {age = 10, money = 11}; //li
Console.WriteLine(v.age)
```

### 17.  a.Equals(b)和a==b⼀样吗?
不⼀样,a==b仅仅表示a和b值相等,a.Equals(b)表示a与b⼀致

17.1. Equals与==的区别
"==" : 操作比较的是两个变量的值是否相等,对于引用型变量表示的是两个变量在堆中存储的地址是否相同,即栈中的内容是否相同。但对于字符串(string)等特殊类型,== 被重载为比较内容。

"equals" : 操作表示的两个变量是否是对同一个对象的引用,即堆中的内容是否相同。 

17.2. 总结如下: 
1、对于值类型,==和equals等价,都是比较存储信息的内容。
2、对于引用类型,==比较的是引用类型在栈中的地址,equals方法则比较的是引用类型在托管堆中的存储信息的内容。
例如,string 类重载了 == 并重写了 Equals,使它们都比较内容。

``` c#
string s3 =new string(new char[]{'t','e','s','t'});
string s4= new string(new char[]{'t','e','s','t'});
Console.WriteLine(s3 == s4);        //True string中重写了== 所以比较的是内容
Console.writeLine(s3.Equals(s4));   //True 也重写了Equals方法

object o3 = s3;          
object o4 = s4;
Console.WriteLine(o3 == 04);        //False 因为 o3 和 o4 指向不同的 string 对象实例,引用地址不同
Console.WriteLine(o3.Equals(o4));   //True equals操作表示的两个变量是否是对同一个对象的引用,即堆中的内容是否相同
```

### 18.  阐述什么是虚方法?它与抽象方法有什么不同?
一个虚方法必须有一个默认实现,我们可以在派生类中使用 override 关键字来覆盖这个虚方法。      
抽象方法没有实现,只在抽象类内部创建。在抽象类的情况下,从抽象类派生的类必须具有该抽象方法的实现。
**虚方法和抽象方法都可以被子类无限的重写** 

### 19.  是否可以从一个static方法内部发出对非static方法的调用?
不可以。因为非static方法是要与对象关联在一起的,必须创建一个对象后,才可以在该对象上进行方法调用,而static方法调用时不需要创建对象,可以直接调用。也就是说,当一个static方法被调用时,可能还没有创建任何实例对象,如果从一个static方法中发出对非static方法的调用,那个非static方法是关联到哪个对象上的呢?这个逻辑无法成立,所以,一个static方法内部不能发出对非static方法的调用。      

## 高级部分
### 1. 浮点数的精度问题     
1.1. 可能出现的问题：       

**数值比较不相等**          
我们在写程序时经常会遇到到阀值触发某逻辑的情景,比如某个变量,需要从0开始加,每次加某个小于0.01的数,加到刚好0.23时做某事,到0.34时做另外一件事,到0.56时再做另一件。                       
这种精确定位的问题,就会遇到麻烦。因为浮点数在加减乘数时无法完全准确定位到某个值,就会在出现,要么比0.23小,要么比0.23大,永远不会刚刚与0.23相等的时候,这时我们不得不放弃 ‘==’ 这个等于号而选择‘>’大于号或者‘<’小于号来解决这种问题的出现。                        
如果一定要用等于来做比较,则需要有一个微小的浮动区间,即 ABS(X-Y) < 0.00001 时认为 X 和 Y 是相等的。  
``` c#                  
float value = 0f;
while (value < 0.23f)
{
    value += 0.01f; //value 的实际值可能是 0.22999999
}
Console.WriteLine(value == 0.23f); // 输出: False
```

**数值计算不确定**      
比如 x = 1f,y = 2f,z = 1f /5555f * 11110f,如果 x / y <= 0.5f 时做某事,那么理论上说 x / z 也能通过这个if,因为在我们看来z 就等于 2 和 y是一样,但实际上未必是这样的。浮点数在计算时由于位数的限制无法得到精确的数值而是一个被截断的数值,因此 z 的计算结果有可能是0.4999999999991,当x / z 时,结果有可能得到大于0.5。       
这让我们很头疼,在实际编码中,我们经常会遇到这样的情况,在外圈的if判断成立,理论上同样的结果只是公式不同,它们在内圈的if判断却可能不成立,使得程序就出现异常行为,因为看起来应该是得到同样的数值,但结果却不一样。      
``` c#  
float x = 1f;
float y = 2f;
float z = 1f / 5555f * 11110f; // 理论上 z 应该等于 2f

if (x / y <= 0.5f) // 0.5f <= 0.5f,条件成立
    Console.WriteLine("Condition 1 passed");

if (x / z <= 0.5f) // 由于 z 的实际值可能是 1.99999999,x / z 可能是 0.50000001,条件不成立
    Console.WriteLine("Condition 2 passed");
```

**不同设备计算结果不同**
不同平台上的浮点数计算也有所偏差,由于不同设备上CPU的计算方式不同,导致相同的公式在不同的设备上计算出来的结果有略微的偏差。

1.2. **解决办法：**     

1. **可以简单点,只计算一次,认定这个值为准确值,只用这个变量结果做判断,也省去了多次计算浪费的CPU**。
当然这种方法使用范围比较小,可能不适用你所在的项目我们可以继续看看其他的解决方案。   
``` c#         
float threshold = 0.23f; // 只计算一次
if (value > threshold)
{
    // 做某事
}
```

2. 可以改用int或long型来替代浮点数。浮点数和整数的计算方式都是一样的,只是小数点部分不同而已,那么完全可以把浮点数乘以10的幂次得到更准确的精度部分的数字,把自己需要的精度提上来用整数表示。   
``` c#            
int value = 0;
int threshold = 23; // 0.23 * 100

while (value < threshold)
    value += 1; // 0.01 * 100

if (value == threshold)
    // 做某事
```

3. 用定点数保持一致性并缩小精度问题,浮点数在计算机中的表示方法是用 V = (-1)^s x (1.M) x 2^(e) 这样的公式表示的,也就是说浮点数的表达其实是模糊的,它用了另一个数乘以2的幂次来表示当前的数。定点数则不同,它把整数部分和小数部分拆分开来,都用整数的形式表示,这样一来计算和表达都使用整数的方式。由于整数的计算是确定的,这样就不会存在误差,缺点是由于拆分了整数和小数,两个部分都要占用空间,所以受到存储位数的限制,占用字节多了通常使用64位的long型整数结构来存储定点数,计算的范围也会相对缩小些。   
``` c#
struct FixedPoint
{
    public long IntegerPart;
    public long FractionalPart;
}   
```      
4. 最耗的办法,用字符串替代浮点数。如果想要精确度很高很高,那么就可以用字符串代替浮点数来计算结果。但它的缺点是CPU和内存的消耗特别大,如果只是少量使用高精度计算还是可以的。            
``` c#
string value = "0.12345678901234567890";
``` 

### 2.
### 3. IList 接⼝与List的区别是什么?
IList 泛型接⼝是 Icollection 接⼝的⼦代,并且是所有⾮泛型列表的基接⼝。 Ilist 实现有三种类别：只读、固定⼤⼩、可变⼤⼩。 ⽆法修改只读 Ilist。 固定⼤⼩的 Ilist 不允许添加或移除元素,但允许修改现有元素。 可变⼤⼩的 Ilist 允许添加、移除和修改元素。               
IList 是个接⼝,定义了⼀些操作⽅法这些⽅法要你⾃⼰去实现,当你只想使⽤接⼝的⽅法时,这种⽅式⽐较好.他不获取实现这个接⼝的类的其他⽅法和字段,有效的节省空间．     
List 是个类型 已经实现了IList 定义的那些⽅法。 

``` c#
// IList<T>接口设计完整例子
using System.Collections;
 
namespace _121_1
{
    public class MyList<T> : IList<T>
    {
        private readonly List<T> list = [];
 
        public int Count
        {
            get { return list.Count; }
        }
 
        public bool IsReadOnly
        {
            get { return false; }
        }
 
        public void Add(T item)
        {
            list.Add(item);
        }
 
        public void Clear()
        {
            list.Clear();
        }
 
        public bool Contains(T item)
        {
            return list.Contains(item);
        }
 
        public int IndexOf(T item)
        {
            return list.IndexOf(item);
        }
 
        public void Insert(int index, T item)
        {
            list.Insert(index, item);
        }
 
        public bool Remove(T item)
        {
            return list.Remove(item);
        }
 
        public void RemoveAt(int index)
        {
            list.RemoveAt(index);
        }
 
        public void CopyTo(T[] array, int arrayIndex)
        {
            throw new NotImplementedException();
        }
        //一个类必须实现它派生的接口的所有成员,否则将被声明abstract
        //注释部分是错误的迭代器设计,不能不设计,注释后警告CS0535
        //public IEnumerator<T> GetEnumerator()
        //{
        //    throw new NotImplementedException();
        //}
        //IEnumerator IEnumerable.GetEnumerator()
        //{
        //    throw new NotImplementedException();
        //}
 
        /// <summary>
        /// 最重要的迭代器接口设计
        /// </summary>
        public IEnumerator<T> GetEnumerator()
        {
            for (int i = 0; i < list.Count; i++)
            {
                yield return list[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
 
        public T this[int index]
        {
            get
            {
                return list[index];
            }
            set
            {
                list[index] = value;
            }
        }
        /// <summary>
        ///  list.Add(1),警告警告CS1503无法将int转为T
        ///  必须经如下换后
        /// </summary>
        public MyList()
        {
            // 初始化列表,并添加一些示例数据
            list.Add((T)(object)1); // 将1强制转换为T类型
            list.Add((T)(object)2); // 将2强制转换为T类型
            list.Add((T)(object)3); // 将3强制转换为T类型
        }
    }
 
    class Program
    {
        static void Main(string[] args)
        {
            ArgumentNullException.ThrowIfNull(args);
 
            MyList<int> myList = [];
            Console.WriteLine("初始列表: {0}", string.Join(", ", myList)); // 初始列表: 1, 2, 3
 
            myList.Add(4);
            Console.WriteLine("添加元素4后的列表: {0}", string.Join(", ", myList)); // 添加元素4后的列表: 1, 2, 3, 4
 
            myList[1] = 8;
            Console.WriteLine("将索引1处的元素替换为2后的列表: {0}", string.Join(", ", myList)); //将索引1处的元素替换为2后的列表: 1, 8, 3, 4
 
            Console.ReadKey();
        }
    }
}

```

### 4. 泛型的主要约束和次要约束是什么?      
当⼀个泛型参数没有任何约束时,它可以进⾏的操作和运算是⾮常有限的,因为不能对实参进⾏任何类型上的保证,这时候就需要⽤到泛型约束。泛型的约束分为：主要约束和次要约束,它们都使实参必须 
满⾜⼀定的规范,C#编译器在编译的过程中可以根据约束来检查所有泛型类型的实参并确保其满⾜约束条件。             
(1)主要约束                 
⼀个泛型参数⾄多拥有⼀个主要约束,主要约束可以是⼀个引⽤类型、class或者struct。如果指定⼀个引⽤类型(class),那么实参必须是该类型或者该类型的派⽣类型。相反,struct则规定了实参必须是 
⼀个值类型。下⾯的代码展示了泛型参数主要约束： 
``` c#                         
public class ClassT1<T> where T : Exception // T 必须是 Exception 或其子类
{ 
 private T myException; 
 public ClassT1(T t) 
{ 
 myException = t; 
 } 
 public override string ToString() 
{ 
 // 主要约束保证了myException拥有source成员 
 return myException.Source; 
 } 
} 
public class ClassT2<T> where T : class 
{ 
 private T myT; 
 public void Clear() 
{ 
 // T是引⽤类型,可以置null 
 myT = null; 
 } 
} 
public class ClassT3<T> where T : struct 
{ 
 private T myT; 
 public override string ToString() 
{ 
 // T是值类型,不会发⽣NullReferenceException异常 
 return myT.ToString(); 
}
``` 
(2) 次要约束 
次要约束主要是指实参实现的接⼝的限定。对于⼀个泛型,可以有0到⽆限的次要约束,次要约束规定了实参必须实现所有的次要约束中规定的接⼝。次要约束与主要约束的语法基本⼀致,区别仅在于提供的不是⼀个引⽤类型⽽是⼀个或多个接⼝。例如我们为上⾯代码中的ClassT3增加⼀个次要约束: 还有无参构造函数
``` c#
public class ClassT3<T> where T : struct, IComparable 
{ 
 ...... 
}
```

### 5. .NET默认的委托类型有哪⼏种?
1. Action < T > 
泛型Action委托表示引⽤⼀个void返回类型的⽅法。这个委托类存在16种重载⽅法。 
例如Action<in T1,In T2>调⽤没有参数的⽅法 
2. Func< T > 
Func调⽤带返回类型的⽅法。有16种重载⽅法。 in是只能作为参数逆变 out作为返回值协变
例如Func委托类型可以调⽤带返回类型且⽆参数的⽅法,Func<in T,out TResult>委托类型调⽤带有4个参数和⼀个返回类型的⽅法。

### 6. 结构体能实现接口吗?
能
```  c#
//结构体班级
struct StructClass : IClass {
    public int Count;//人数
    public void AddStudent() {
        Count++;
    }

    public void ShowCount() {
        Console.WriteLine(Count);
    }

}
//接口
interface IClass {
    void AddStudent();//添加学生
    void ShowCount();//显示学生人数
}
class Program {
    static void Main(string[] args) {
        StructClass s1 = new StructClass();
        StructClass s2 = s1;
        s1.AddStudent();
        s1.ShowCount(); //输出1
        s2.ShowCount(); //输出0
        //说明s2和s1不指向同一个对象,s2=s1是创建了一个s1的副本
        //这是值类型很显著的标志

        IClass ic1 = new StructClass(); //引用类型
        IClass ic2 = ic1;
        ic1.AddStudent();
        ic1.ShowCount();//输出1
        ic2.ShowCount();//输出1
        //说明s2和s1指向同一个对象,s2=s1是将s1的引用赋给s2
        //这是引用类型很显著的标志
    }
}
``` 

### 7. 如何C#理解委托?
1、什么是委托
委托可以理解为持有一个或多个方法的对象。如果执行委托的话，委托会执行它所"持有"的方法。委托可以避免程序中大量使用if-else语句，使程序拥有更好的扩展性。
2、委托的本质
委托和类一样，是一种用户自定义的类型，但类表示的是数据和方法的集合，而委托则持有一个或多个方法，以及一系列预定义的操作。
3、如何声明委托
delegate void MyDel(int x)
说明：delegate 作为委托关键字，没有方法主体
4、什么是多播委托？
可以把多个方法赋值给同一个委托，或者将多个方法绑定到同一个委托，就是多播委托。

### 8. 什么是event,它和delegate又有什么关系?
event 很简单，它在委托delegate上，又做了一次封装，这次封装的意义是，限制用户直接操作delegate委托实例中变量的权限。              
封装后，用户不再能够直接用赋值(即使用 = 等号操作符)操作来改变委托变量了，只能通过注册或者注销委托的方法来增减委托函数的数量。也就是说被 event 声明的委托不再提供 ‘=’ 的操作符，但仍然有 ‘+=’ 和 ‘-=’ 的操作符可供操作。                     
为什么要限制呢？因为在平时的编程中，由于项目太过庞大，经手的人员数量太多，导致我们常常无法得知其他人在编写的代码是什么有什么意图，这样公开的delegate委托会直接暴露在外，随时会被‘=’赋值而清空了前面累积起来的委托链表，委托的操作权限范围太大导致问题会比较严重。申明 event 后，编译器内部重新封装了委托，让暴露在外面的委托不再担心随时被清空和重置的危险。因为经过 event 封装后不再提供赋值操作来清空前面的累加，只能一个个注册或者一个个注销委托(或者说函数地址)，这样就保证了谁注册就必须谁负责销毁的目的，更好的维护了delegate的秩序。                     

### 9. 什么是泛型委托?                      
Action就是泛型委托。                
注意事项：                          
1. 建议尽量使⽤这些委托类型，⽽不是在代码中定义更多的委托类型。这样可以减少系统中的类型数⽬，同时简化编码            
2. 如果需要使⽤ref或out关键字，以传引⽤的⽅式传递⼀个参数，就可能不得不定义⾃⼰的委托: delegate void Test(ref int i)    
3. 如果委托要通过C#的params关键字获取可变数量的额参数，要为委托的任何参数指定默认值，或者要对委托的泛型类型参数进⾏约束，也必须定义⾃⼰的委托类型          
delegate void EventHandler(Object sender, TEventArgs e) where TEventArgs : EventArgs; 
    
4. 使⽤获取泛型实参和返回值的委托时，可利⽤逆变与协变。逆变：⽗类转换为⼦类；协变：⼦类转换为⽗类
协变和逆变都是用来修饰泛型的 只有**泛型接口**和**泛型委托**能使用                       
**协变out** **逆变in** 


### 10. try {}⾥有⼀个return语句,那么紧跟在这个try后的finally {}⾥的code会不会被执⾏,什么时 候被执⾏,在return前还是后?
会执⾏，在return前执⾏。
try中代码如果出错 执行 catch代码
不管有没有出错都会执行finally

### 11. C#中 property 与 attribute的区别,他们各有什么用处,这种机制的好处在哪里?
property和attribute汉语都称之为属性。不过property是指类向外提供的数据区域。而attribute则是描述对象在编译时或运行时属性的。这两者是有本质区别的.

1. Property（属性）
Property 是类或结构体中的成员，用于封装字段（Field），提供对字段的访问和修改。
它通常包含 get 和 set 访问器，分别用于读取和写入字段的值。
封装性：隐藏内部实现细节，提供统一的访问接口。
灵活性：可以在 get 和 set 访问器中添加逻辑，控制字段的访问和修改。

Attribute 是一种元数据，用于为程序元素（如类、方法、属性等）添加额外的信息。
它不会影响程序的执行逻辑，但可以通过反射（Reflection）在运行时读取这些信息。

### 12. 反射的实现原理?
反射其是审查元数据并收集关于它的类型信息的能力，元数据（编译后的最基本数据单元）一些表。可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段
主要使用的类库：System.Reflection
核心类：
Assembly 描述了程序集
Type 描述了类这种类型
ConstructorInfo 描述了构造函数
MethodInfo 描述了所有的方法
FieldInfo 描述了类的字段
PropertyInfo 描述类的属性
通过以上核心类可在运行时动态获取程序集中的类，并执行类构造产生类对象，动态获取对象的字段或属性值，更可以动态执行类方法和实例方法等。

**程序集**  是由编译器编译得到的 供进一步编译执行的中间产物           
.dll 库文件和.exe 可执行文件   
反射是Unity的基本工作机制       

**元数据**
是用来描述数据的数据        
程序中的类 类中的函数.变量等等信息就是程序的元数据      
有关程序已经类型的数据被称为元数据 保存在程序集中 

### 反射
程序正在运行时 可以查看其他程序集或者自身的元数据  

**反射** 一个运行的程序查看本身或者其他程序的元数据的行为                
程序运行时,可以通过反射得到其他程序集或者自己程序集代码的各种信息 

优缺点
**优点：**
1、反射提高了程序的灵活性和扩展性。
2、降低耦合性，提高自适应能力。
3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。

**缺点：**
1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。
2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。

### 13. 解释 var 和 dynamic ?
我们可以声明变量的 var 类型，而无需明确指定 .net 数据类型。编译器在编译时根据分配给它的值自动检测变量的类型。我们不能声明一个 var 类型的变量而不给它赋值。var 类型变量的值不能在后面的代码中更改。动态与var相反。

稍后我们可以在代码中更改动态类型变量的值。它还根据分配给它的值决定变量的类型。 就像在创建动态类型的变量时，会为其分配一个整数类型的值，然后在进一步的代码中，我们可以为该变量分配一个字符串类型的值。它保存最后更改的值，其行为类似于它保存的最新值的数据类型。让我们看这个例子来更详细地理解它。

在上面的示例中，如果我们将变量“someValue”声明为 var 而不是 dynamic，则会引发错误。该错误的原因是在下一行中，我们更改了变量的值并分配了一个字符串值。
``` c#
public class Bike
{
dynamic someValue = 21;

public Bike()
{
//assigned string value later
someValue = "Hello";
}
}
```
### 14. 如何避免类型转换时的异常?
其中有些是确定可以转换的（⽐如将⼀个⼦类类型转为⽗类类型），⽽有些则是尝试性的（⽐如将基类
引⽤的对象转换成⼦类）。当执⾏常识性转换时，我们就应该做好捕捉异常的准备。          
当⼀个不正确的类型转换发⽣时，会产⽣InvalidCastException异常，有时我们会⽤try-catch块做⼀些
尝试性的类型转换，这样的代码没有任何错误，但是性能却相当糟糕，为什么呢？异常是⼀种耗费资源
的机制，每当异常被抛出时，异常堆栈将会被建⽴，异常信息将被加载，⽽通常这些⼯作的成本相对较
⾼，并且在尝试性类型转换时，这些信息都没有意义。                
在.NET中提供了另外⼀种语法来进⾏尝试性的类型转换，那就是关键字 is 和 as 所做的⼯作。        
（1）is 只负责检查类型的兼容性，并返回结果：true 和 false。→ 进⾏类型判断   
is 关键字用于检查一个对象是否与指定类型兼容（即是否是该类型或其派生类型，或者是否实现了某个接口）。  
``` c#  
public static void Main(string[] args)
{
	object o = new object();
	// 执⾏类型兼容性检查
	if(o is ISample) //false
	{
		// 执⾏类型转换
		ISample sample = (ISample)o;
		sample.SampleShow();
	}
	Console.ReadKey();
}
```
（2）as 不仅负责检查兼容性还会进⾏类型转换，并返回结果，如果不兼容则返回 null 。→ ⽤于类型
转型
``` c#
public static void Main(string[] args)
{
	object o = new object();
	// 执⾏类型兼容性检查
	ISample sample = o as ISample;
	if(sample != null)
	{
		sample.SampleShow();
	}
	Console.ReadKey();
}
```
两者的共同之处都在于：不会抛出异常！综上⽐较，as 较 is 在执⾏效率上会好⼀些，在实际开发中应
该量才⽽⽤，在只进⾏类型判断的应⽤场景时，应该多使⽤ is ⽽不是 as。

### 15. Dictionary 底层原理
我们知道 Dictionary 字典型数据结构，是以关键字Key 和 值Value 进行一一映射的。Key的类型并没有做任何的限制，可以是整数，也可以是的字符串，甚至可以是实例对象。关键字Key是如何映射到内存的呢？
对于Dictionary的实现原理，其中有两个关键的算法，    
● 一个是Hash算法，  
● 一个是用于应对Hash碰撞冲突解决算法。
实现原理
1. 哈希算法：将不定长度的二进制数据集给映射到一个较短的二进制长度数据集一个Key通过HashFunc得到HashCode
2. Hash桶算法：对HashCode进行分段显示，常用方法是对HashCode直接取余，桶本身是用的数组。
3. 解决碰撞冲突算法（拉链法）：分段会导致key对应的桶会相同，拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置。反之就是通过确定hash桶位置后，遍历单链表，获取对应的value

Dictionary 是以数组为底层数据结构的类。当我们实例化 new Dictionary() 后，内部的数组是0个数组的状态。与 List 组件一样，Dictionary 也是需要扩容的，会随着元素数量的增加而不断扩容

### 16. C#的GC原理(注意这个是C#的GC,Unity的GC在这里)

16.1. GC 算法基于几个注意事项：

● 压缩托管堆的一部分内存要比压缩整个托管堆速度快。
● 较新的对象生存期较短，而较旧的对象生存期则较长。
● 较新的对象趋向于相互关联，并且大致同时由应用程序访问。

垃圾回收主要在回收短生存期对象时发生。 为优化垃圾回收器的性能，将托管堆分为三代：第 0 代、第 1 代和第 2 代，因此它可以单独处理长生存期和短生存期对象。 垃圾回收器将新对象存储在第 0 代中。 在应用程序生存期的早期创建的对象如果未被回收，则被升级并存储在第 1 级和第 2 级中。 因为压缩托管堆的一部分要比压缩整个托管堆速度快，所以此方案允许垃圾回收器在每次执行回收时释放特定级别的内存，而不是整个托管堆的内存。

● 第 0 代。 这是最年轻的代，其中包含短生存期对象。 短生存期对象的一个示例是临时变量。 垃圾回收最常发生在此代中。新分配的对象构成新一代对象，并隐式地成为第 0 代集合。 但是，如果它们是大型对象，它们将延续到大型对象堆 (LOH)，这有时称为第 3 代。 第 3 代是在第 2 代中逻辑收集的物理生成。大多数对象通过第 0 代中的垃圾回收进行回收，不会保留到下一代。如果应用程序在第 0 代托管堆已满时尝试创建新对象，垃圾回收器将执行收集，以尝试为该对象释放地址空间。 垃圾回收器从检查第 0 级托管堆中的对象（而不是托管堆中的所有对象）开始执行回收。 单独回收第 0 代托管堆通常可以回收足够的内存，这样，应用程序便可以继续创建新对象。对象很大，它们将进入大对象堆.

● 第 1 代。 这一代包含短生存期对象并用作短生存期对象和长生存期对象之间的缓冲区。垃圾回收器执行第 0 代托管堆的回收后，会压缩可访问对象的内存，并将其升级到第 1 代。 因为未被回收的对象往往具有较长的生存期，所以将它们升级至更高的级别很有意义。 垃圾回收器不必在每次执行第 0 代托管堆的回收时，都重新检查第 1 代和第 2 代托管堆中的对象。如果第 0 代托管堆的回收没有回收足够的内存供应用程序创建新对象，垃圾回收器就会先执行第 1 代托管堆的回收，然后再执行第 2 代托管堆的回收。 第 1 级托管堆中未被回收的对象将会升级至第 2 级托管堆。

● 第 2 代。 这一代包含长生存期对象。 长生存期对象的一个示例是服务器应用程序中的一个包含在进程期间处于活动状态的静态数据的对象。第 2 代托管堆中未被回收的对象会继续保留在第 2 代托管堆中，直到在将来的回收中确定它们无法访问为止。大型对象堆上的对象（有时称为 第 3 代）也在第 2 代中收集。
当条件得到满足时，垃圾回收将在特定代上发生。 回收某个代意味着回收此代中的对象及其所有更年轻的代。 第 2 代垃圾回收也称为完整垃圾回收，因为它回收所有代中的对象（即，托管堆中的所有对象）。

16.2. 幸存和提升
垃圾回收中未回收的对象也称为幸存者，并会被提升到下一代：
● 第 0 代垃圾回收中未被回收的对象将会升级至第 1 代。
● 第 1 代垃圾回收中未被回收的对象将会升级至第 2 代。
● 第 2 代垃圾回收中未被回收的对象将仍保留在第 2 代。
当垃圾回收器检测到某个代中的幸存率很高时，它会增加该代的分配阈值。 下次回收将回收非常大的内存。 CLR 持续在以下两个优先级之间进行平衡：不允许通过延迟垃圾回收，让应用程序的工作集获取太大内存，以及不允许垃圾回收过于频繁地运行。

16.3. 垃圾回收分为以下几个阶段
● 标记阶段，找到并创建所有活动对象的列表。
● 重定位阶段，用于更新对将要压缩的对象的引用。
● 压缩阶段，用于回收由死对象占用的空间，并压缩幸存的对象。 压缩阶段将垃圾回收中幸存下来的对象移至段中时间较早的一端。因为第 2 代回收可以占用多个段，所以可以将已提升到第 2 代中的对象移动到时间较早的段中。 可以将第 1 代幸存者和第 2 代幸存者都移动到不同的段，因为它们已被提升到第 2 代。

"标记"本领——垃圾的识别：从应用程序的root出发，利用相互引用关系，遍历其在Heap上动态分配的所有对象，没有被引用的对象不被标记，即成为垃圾；存活的对象被标记，即维护成了一张"根-对象可达图"。其实，CLR会把对象关系看做"树图"，这样会加快遍历对象的速度。.Net中利用栈来完成检测并标记对象引用，在不断的入栈与出栈中完成检测：先在树图中选择一个需要检测的对象，将该对象的所有引用压栈，如此反复直到栈变空为止。栈变空意味着已经遍历了这个局部根能够到达的所有对象。树图节点范围包括局部变量、寄存器、静态变量，这些元素都要重复这个操作。一旦完成，便逐个对象地检查内存，没有标记的对象变成了垃圾。

"清除"本领——回收内存：启用压缩（Compact）算法，对内存中存活的对象进行移动，修改它们的指针，使之在内存中连续，这样空闲的内存也就连续了，这就解决了内存碎片问题，当再次为新对象分配内存时，CLR不必在充满碎片的内存中寻找适合新对象的内存空间，所以分配速度会大大提高。但是大对象（large object heap）除外，GC不会移动一个内存中巨无霸，因为它知道现在的CPU不便宜。通常，大对象具有很长的生存期，当一个大对象在.NET托管堆中产生时，它被分配在堆的一个特殊部分中，移动大对象所带来的开销超过了整理这部分堆所能提高的性能。

///////////////
垃圾回收的过程是在遍历堆(heap)上动态分配的所有对象      
通过识别他们是否被引用来确定哪些对象是垃圾 哪些对象要被使用         
垃圾指的是没有被任何变量, 对象引用的内容     
垃圾需要被回收释放  

GC只负责堆Heap内存的垃圾回收 引用类型存在堆heap中       
栈stack上的内存是由系统自动管理的 值类型在栈中会自动分配和释放              

**原理** 分代算法   
0代内存 1代内存 2代内存     
新分配的对象都会先进入0代内存中         
当0代内存满时 进行垃圾回收以释放内存    
在内存回收过程中 垃圾回收器会认为堆中全是垃圾       
首先进行标记对象 从根(静态字段,方法参数)来检查引用对象, 标记后为可达对象，未标记为不可达对象 不可达对象被认为是垃圾         
然后进行释放未标记对象,搬迁可达对象,修改引用地址            
1代和2代释放都会对之前代一起释放    

大对象总被人为是第二代内存 目的减少性能损耗 提高性能        
不会对大对象进行搬迁压缩 85000字节83kb以上对象为大对象      

``` c#
// 手动触发垃圾回收的方法
// 不会频繁调用
// 在Loading过场景时才调用
GC.Collect();

``` 

## 多线程
### 1. 描述线程与进程的区别?
线程(Thread)与进程(Process)⼆者都定义了某种边界,不同的是进程定义的是应⽤程序与应⽤程序之间的边界,不同的进程之间不能共享代码和数据空间,⽽线程定义的是代码执⾏堆栈和执⾏上下⽂的边界。            

⼀个进程可以包括若⼲个线程,同时创建多个线程来完成某项任务,便是多线程。⽽同⼀进程中的不同线程共享代码和数据空间。⽤⼀个⽐喻来说,如果⼀个家庭代表⼀个进程,在家庭内部,各个成员就是线程,家庭中的每个成员都有义务对家庭的财富进⾏积累,同时也有权利对家庭财富进⾏消费,当⾯对⼀个任务的时候,家庭也可以派出⼏个成员来协同完成,⽽家庭之外的⼈则没有办法直接消费不属于⾃⼰家庭的财产。            

### 2. 前台线程和后台线程有什么区别?        
设置成后台线程  
当前台线程都结束时 整个程序也就结束了 即使还有后台线程还在运行      
后台线程不会防止进程被终止掉        
当新开线程是死循环时 主进程运行完了 但是依然不会结束    
主线程结束就应该都结束 默认线程是前台线程           

通过将 Thread.IsBackground 属性设置为 true,就可以将线程指定为后台线程       
前台线程： 应⽤必须结束掉所有的前台线程才能结束程序,只要有⼀个前台线程没退出进程就不会⾃动退出,当然线程是依附在进程上的,所以你直接把进程KO掉了的话⾃然所有前台线程也会退出。         
后台线程： 进程可以不考虑后台直接⾃动退出,进程⾃动退出后所有的后台线程也会⾃动销毁      

### 3.Task状态机的实现和⼯作机制是什么？        

在C#中，Task 类是用于表示异步操作的一种方式。Task状态机实现了异步编程模型，其中异步操作以状态机的形式表达。以下是Task状态机的实现和工作机制的简要说明： 
**Task状态机的实现**        
Task状态机的实现基于 async 和 await 关键字。async 方法通过状态机的方式来处理异步操作，await 关键字用于暂停异步方法的执行，等待异步操作完成。        
``` c#
//async 用于声明一个异步方法。它告诉编译器该方法包含异步操作
//当编译器遇到 async 方法时，它会将该方法转换为一个状态机。这个状态机负责管理异步方法的执行流程，包括暂停和恢复
//状态机通过维护一个状态变量来跟踪异步方法的执行位置。每次 await 一个任务时，状态机都会记录当前的位置，并在任务完成后从该位置继续执行。
//Task 表示一个没有返回值的异步操作
//async 用于声明一个异步方法。它告诉编译器该方法包含异步操作
async Task MyAsyncMethod()
{
  Console.WriteLine("Before await");

  await SomeAsyncOperation(); // 暂停，等待 SomeAsyncOperation 完成
  // 这里会生成状态机代码 await 用于暂停异步方法的执行，直到等待的异步操作完成。它只能在 async 方法中使用
  // 当 await 一个任务时，编译器会生成代码来检查任务是否已经完成。如果任务未完成，await 会将控制权返回给调用者，允许其他代码继续执行。当任务完成后，异步方法会从暂停的地方继续执行。
  await Task.Delay(1000); // 暂停执行，等待 1 秒
  Console.WriteLine("After await");
}
public async void TestAsync()       //async用于修饰函数 表示这是个异步方法  下面需要有await配合使用
{
    print("进入异步方法");             //执行
    await Task.Run(() =>            // await 和 task配合使用 开启一个线程 
    {                               //将控制权返回给调用者 执行外部的代码了
        Thread.Sleep(5000);         //当这个线程执行完毕后
    });
    //3
    print("异步方法后面的逻辑");    //再执行后面的内容
}
TestAsync(); //1先打印"进入异步方法" 遇到await挂起 2再打印"主线程逻辑执行" 等await Task执行完了 3打印"异步方法后面的逻辑"

print("主线程逻辑执行");
``` 

上述代码中，await SomeAsyncOperation() 的执行会生成状态机代码，将异步操作的执行过程以状态机的形式表示，使得在异步操作未完成之前，MyAsyncMethod 可以被暂时挂起而不阻塞线程。

**Task状态机的工作机制**
异步方法启动： 当调用一个使用 async 修饰的异步方法时，该方法的执行将立即返回一个 Task 对象，表示异步操作的状态。
生成状态机： 在编译时，编译器会对包含 await 关键字的异步方法生成一个状态机。这个状态机是一个类，负责跟踪异步操作的状态和执行过程。
挂起和继续： 当 await 关键字遇到一个尚未完成的异步操作时，异步方法会被暂停，状态机会将控制权还给调用者。当异步操作完成时，更新状态 状态机会通过回调机制通知异步方法继续执行。
非阻塞： 异步方法的执行过程中，不会阻塞线程。线程可以继续执行其他任务，提高了程序的并发性。
Task 完成： 当异步操作完成时，相关的 Task 对象的状态会从等待状态变为完成状态，可以通过 Task 的 Result 属性获取异步操作的结果
使用async和await的异步编程模型可以使异步代码更加清晰、简洁，并提供更好的可读性和维护性。

### 4.await的作⽤和原理，并说明和GetResult()有什么区别**？
await 关键字是用于在异步方法中等待异步操作完成的关键字，其主要作用是使异步代码更加清晰和易读。await 关键字的原理是将异步操作挂起，不阻塞线程的同时允许其他任务执行，直到异步操作完成后恢复执行异步方法。

**await 的作用**
挂起执行： 当遇到 await 关键字时，异步方法的执行会在此处暂停，控制权会返回给调用者，而不会阻塞线程。
异步等待： await 会等待异步操作完成。一旦异步操作完成，异步方法会继续执行。
简化异步代码： 通过 await，异步代码可以以同步的形式编写，提高代码的可读性和维护性。

**await 的原理**
生成状态机： 编译器在编译时会生成一个状态机，用于跟踪异步操作的状态和执行过程。
任务挂起： 当 await 遇到一个未完成的异步操作时，它会将异步方法的执行挂起，控制权返回给调用者。
注册回调： await 会注册一个回调，当异步操作完成时，回调会通知状态机，继续执行异步方法。

**区别与GetResult()**
await： 在异步方法中使用 await 关键字时，异步操作完成后会自动恢复执行异步方法。此时，线程不会被阻塞，其他任务可以执行。
``` c#
async Task MyAsyncMethod()
{
  Console.WriteLine("Before await");
  await SomeAsyncOperation(); // 挂起，等待异步操作完成
  Console.WriteLine("After await");
}
``` 

GetResult()： 使用 GetResult() 方法时，会立即等待异步操作的完成，并获取其结果。这样会阻塞当前线程，直到异步操作完成。这种方式适用于需要立即获取异步操作结果的情况，但不适用于需要保持非阻塞的异步执行的情况。
``` c#
void MyMethod()
{
  Console.WriteLine("Before GetResult");
  SomeAsyncOperation().GetResult(); // 立即等待异步操作完成
  Console.WriteLine("After GetResult");
}
```
总体来说，await 更适合异步编程的场景，使得代码更加清晰和异步执行。而 GetResult() 则是一种同步等待异步操作完成的方式，适用于某些需要立即获取结果的情况。但在大多数情况下，应优先选择使用 await。

### 5. Task和Thread有区别吗？
是的，Task 和 Thread 是两个在C#中用于处理并发和多线程的不同概念。以下是它们的主要区别：

1. Task类是基于Thread的封装
2. Task类可以有返回值，Thread没有返回值
3. Task类可以执行后续操作，Thread没有这个功能
4. Task可以更加方便的取消任务 延迟取消**、**取消回调 ，Thread相对更加单一
5. Task具备ThreadPool线程池的优点，更节约性能

**Task**
Task 是一个更高级的抽象，它建立在线程之上，并提供对异步操作的支持。Task 是以任务（Task）的形式表示的，可以用于表示并行执行的工作单元。
Task 主要用于支持异步编程模型（Async Programming Model），通过 async 和 await 关键字可以更轻松地处理异步操作。
Task 提供了对任务的取消（Cancellation）和延续（Continuation）的支持，允许在任务完成时执行额外的操作。
而且有Wait方法 实现线程阻塞 调整不同线程的优先级 等到这些线程执行完 才会执行后面的逻辑    
``` c#
t1.Wait(); //等到t1执行完 才会执行后面的逻辑    
//2.WaitAny静态方法：传入任务中任意一个任务结束就继续执行
Task.WaitAny(t1, t2); // t1/t2 有一个执行完后面就会执行了
//3.WaitAll静态方法：任务列表中所有任务执行结束就继续执行
Task.WaitAll(t1, t2);

// Continuation
Task.WhenAll(t1).ContinueWith((t) =>) //当t1完成后 执行后面的
Task.Factory.ContinueWhenAll(new Task[] { t1, t2 }, (t) =>)
Task.WhenAny(t1, t2).ContinueWith((t) =>) //传入任务只要有一个执行完毕后再执行某任务
CancellationTokenSource c = new CancellationTokenSource();

// Cancellation
//取消
CancellationTokenSource c = new CancellationTokenSource();
c.Cancel();
//延迟取消
c.CancelAfter(5000);
//取消回调 当这个线程取消的时候调用
c.Token.Register(() =>
{
    print("任务取消了");
});
``` 


**Thread**
Lower-level Construct: Thread 是一个更低级别的构造，直接表示一个执行线程。它是操作系统提供的线程的直接映射，更接近硬件级别。
Synchronous and Blocking: Thread 主要用于同步和阻塞式的多线程编程。线程启动后，会一直执行直到任务完成或显式终止。
No Built-in Support for Asynchronous Programming: Thread 没有内置的异步编程支持，需要使用传统的同步和锁定机制来处理并发问题。
Explicit Management: 开发人员需要显式管理线程的生命周期、同步和互斥，这可能导致更复杂的代码。

总结：
如果你需要执行一些并行的、异步的工作，并且希望更高级的抽象和异步编程模型，那么使用 Task 是更合适的选择。
如果你需要更底层、直接控制线程的执行，或者在一些传统的多线程方案中使用线程的概念，那么使用 Thread 是合适的。
通常情况下，在现代C#开发中，更推荐使用 Task 和异步编程的方式来处理并发和多线程问题。

### 6. 线程池的有点和不⾜?
优点：减⼩线程创建和销毁的开销，可以复⽤线程；也从⽽减少了线程上下⽂切换的性能损失；在GC回收时，较少的线程更有利于GC的回收效率。

缺点：线程池⽆法对⼀个线程有更多的精确的控制，如了解其运⾏状态等；不能设置线程的优先级；加⼊到线程池的任务（⽅法）不能有返回值；对于需要⻓期运 
⾏的任务就不适合线程池。


### 7. Mutex和lock有什么不同？⼀般⽤哪⼀种⽐较好？
Mutex 和 lock 都是用于多线程编程中实现同步和互斥的机制，但它们有一些关键的区别：

Mutex：
**系统级别**
Mutex 是一个系统级别的互斥锁，可以用于不同进程之间的同步。在同一进程内，可以通过命名 Mutex 实现跨线程同步。
**跨进程**
Mutex 可以用于跨进程同步，这意味着不同进程中的线程可以使用同一个 Mutex 进行同步。
**释放所有者**
Mutex 是手动释放的，它允许一个线程获取锁并在后续的某个时间释放。如果线程崩溃，Mutex 不会自动释放，需要手动进行处理。

``` c#
Mutex mutex = new Mutex(); //创建
mutex.WaitOne(); //请求获取 如果 Mutex 已经被其他线程持有，当前线程将被阻塞，直到 Mutex 被释放。
mutex.ReleaseMutex(); //释放 Mutex

// 命名 Mutex: 通过指定名称，不同进程可以使用同一个 Mutex 进行同步。
//全局命名空间: 使用 Global\\ 前缀可以在全局命名空间中创建 Mutex，使得不同用户会话中的进程也可以共享该 Mutex。
Mutex mutex = new Mutex(false, "Global\\MyNamedMutex");

// 创建一个命名 Mutex，名称为 "Global\\MyNamedMutex"
using (Mutex mutex = new Mutex(false, "Global\\MyNamedMutex"))
{
Console.WriteLine("Process 1: Waiting for the mutex...");
// 请求获取 Mutex
bool hasHandle = mutex.WaitOne(5000); // 等待 5 秒
if (!hasHandle){}
}

```

lock:
**应用级别**
lock 是 C# 中的关键字，用于实现应用级别的互斥锁。它是在编程语言层面上提供的语法糖，用于简化 Monitor 类的使用。

**单进程**
lock 仅在同一进程内的不同线程之间起作用，不能跨进程使用。

**自动释放**
lock 是自动释放的，一旦进入临界区，当代码块执行完成或发生异常时，锁会自动释放。
``` c#
object lockObject = new object();
lock (lockObject)
{
  // 临界区
}
```

选择使用的考虑因素：
**应用范围**
如果需要跨进程同步，则应选择 Mutex。如果只需要在同一进程内的线程之间同步，lock 更为简单。
**自动释放**
如果希望锁在退出临界区时自动释放，可以选择 lock。如果需要手动控制锁的释放，可以选择 Mutex。
**性能**
lock 是更轻量级的机制，通常在单进程场景下性能更好。但在跨进程场景中，需要使用 Mutex。

一般情况下，如果在同一进程内实现线程同步，且不需要手动释放锁，推荐使用 lock。如果需要跨进程同步或者需要手动控制锁的释放，可以选择 Mutex。