
- [Canvas画布](#canvas画布)
  - [Canvas组件的参数 **Render Mode**](#canvas组件的参数-render-mode)
  - [Canvas Scaler](#canvas-scaler)
  - [Graphic Raycaster](#graphic-raycaster)
  - [图集](#图集)
  - [1. 静态合批技术](#1-静态合批技术)
  - [2. 动态合批](#2-动态合批)
  - [3. GPU Instancing](#3-gpu-instancing)
  - [4. SRP Batcher](#4-srp-batcher)
- [RectTransform和Transform](#recttransform和transform)


## Canvas画布
Canvas就相当于画画时铺在上边的画板,我们把各类元素放在画布上后,Canvas要做的事情就是合并这些元素.

合并的规则为,同一个Canvas里,相同层级的,相同材质球的元素进行合并,从而减少Drawcall。不过相同层级的概念并不是gameobject 上的节点层级,而是覆盖层级。Canvas说如果两个元素重叠,则可以认为它们是上下层关系,把所有重叠的层级数计算完毕后,第0层的所有元素统一合并,第1层的元素也统一合并,以此类推

### Canvas组件的参数 **Render Mode**
Canvas上的参数 Render Mode 渲染模式比较重要,这里详细介绍下

**Overlay模式**
你可以选择不以Camera为基准的**Overlay模式**, 覆盖模式 UI始终在前
Overlay模式并不与空间上排序有任何关系,空间上的前后位置不再对元素起作用,它常用在纯UI的区域内,这种模式下Camera排序有别与其他模式,Sort order参数在排序时被着重使用到,Sort order参数的值越大,越靠前渲染。在这个模式下没有Camera的渲染机制因此很难加入普通的3D模型物体来增加效果。
**Sort order**: 排序层编号用于控制多个Canvas时渲染先后顺序  编号越大 越后面渲染 会覆盖前面的

**Screen Camera模式**
也可以选择Camera为基准的**Screen Camera模式**, 摄像机模式 3D物体可以显示在UI之前 比如绝地求生的装备栏tab
Screen Camera模式,相对比较通用一点,它依赖于Camera的平面透视,渲染时的布局依赖于它绑定的Camera。想让更多的非UGUI元素加入到UI中,Screen Camera模式更加具有优势。这种模式是实际项目中**制作UI最常用的模式**,不过UGUI底层有对排序做些规则,如对元素的z轴不为0的元素,会单独提取出来渲染,不参与合并。
一般摄像机不会选择主摄像机 专门使用一个摄像机来渲染UI层 UI摄像机为0层级 主摄像机为1 所以会把主摄像机内容覆盖掉 所以需要将UI摄像机设置为Depth only透明模式 Culling Mask为UI 如果想要UI上显示物体 可以把物体创建在UI子对象下 层级改成UI
Sorting Layer 是层级的不同 Order Layer是同层级渲染的顺序

**World Space模式**
也可以选择3D世界为基准的**World Space模式**。三者适合于三种不同的的使用场景各有不同。
World Space模式,主要用于当UI物体放在3D世界中时用的,比如,一个大的场景中,需要将一张标志图放在一个石块头上,这时就需要World Space模式。它与 Screen Camera 的区别是,它常在世界空间中与普通3D物体一同展示,依赖于截锥体透视(Perspective)Camera。它的原理挺简单的,与普通物体一样当UI物体在这个Camera视野中时,就相当于渲染了一个普通的3D面片,只不过除了普通的渲染Canvas还对这些场景里的UI进行合并处理。

### Canvas Scaler
这是个缩放比例组件,用来指定画布中元素的比例大小。用于分辨率自适应的组件
**Constant Pixel Size**
恒定大小模式 无论屏幕大小如何 UI始终保持相同的像素大小
有简单指定比例大小的Constant Pixel Size模式,
**Scale With Screen Size**
也有Scale With Screen Size以屏幕为基准的自动适配比例大小,
根据屏幕尺寸进行缩放 随着屏幕尺寸放大缩小
在实际手游项目里,设备的屏幕分辨率变化比较大,通常使用以屏幕为基准的自动适配比例大小的Scale With Screen Size选项。
**Constant Physical Size**
或者Constant Physical Size以物理大小为基准的适配规则。
无论屏幕大小和分辨率如何 UI元素始终保持相同物理大小

### Graphic Raycaster
图像射线投射器 用于检测UI输入事件的射线发射器 
负责通过射线检测玩家和UI元素的交互 判断是否点击到了UI
输入系统的图形碰撞测试组件,它并不会检测Canvas以外的内容,检测的都是画布下的元素。当图元素上存在有效的碰撞体时,Graphic Raycaster 组件会统一使用**射线碰撞测试**来检测碰撞的元素。
我们也可以设置完全忽略输入的方式来彻底取消点击响应,也可以指定阻止对某些layers进行相应。

**UGUI原理**
首先UGUI是在3D网格下建立起来的UI系统,它的每个可显示的元素都是以3D模型网格的形式来构建起来的。**当UI被实例化时,UGUI首先要做的事就是构建网格。也就是说当Unity3D制作一个图元,或者一个按钮,或者一个背景时,都会先构建一个方形网格,再将图片放入网格中。**可以理解为制造了一个3D模型,用一个网格绑定一个材质球,材质球里存放了要显示的图片。
当你在 Unity 中创建一个 UI 元素(比如一个 Image),**UGUI 会为这个元素生成一个四边形网格。这个网格是一个简单的 2D 平面,用于显示 UI 元素。**
每个 UI 元素都需要一个材质球来定义它的外观(比如颜色、纹理、Shader 等)。材质球中会存放一张图片(纹理),这张图片就是 UI 元素显示的内容**

如果每个元素都会生成一个模型并且绑定一个材质球存入一张图片的话,UI上成千上百个元素就会拥有成千上百个材质球,以及成千上百张图。这样使得引擎在渲染时都需要读取成千上百张图,对每个材质球和网格都进行渲染,这会导致性能开销巨大,drawcall过高,可以简单的理解为一个材质球一个drawcall。
**GPU 需要为每个 Draw Call 进行状态切换(比如切换材质、纹理等)**,这些切换操作会消耗时间。如果 Draw Call 过多,GPU 就会花费大量时间在状态切换上,而不是实际的渲染工作,导致帧率下降。

UGUI当然做了优化,**它将一部分相同类型的图片都集合起来合成一个张图,然后将拥有相同图片相同shader的材质球合并成一个材质球**,**并且把分散开的模型网格也一起合并了**,这样就生成了几个大网格和几个材质球,以及少许整张的图集。
节省了很多材质球,图片,网格的渲染,UI的效率更高了很多,游戏在进行时才会顺畅。这就是我们常常在UI制作中提到的图集的概念,它把很多张图片都放置在一张图集上,导致大量的图片和材质球不需要重复的绘制,只要改变模型顶点上的uv即可。每张小图片在图集中的位置和大小通过 UV 坐标 来表示. 在渲染时,GPU 只需要根据 UV 坐标从图集中提取对应的小图片,而不需要为每个小图片单独切换纹理. 

UGUI也并不是所有的网格和材质球都合并成一个,只有把相同层级的元素,以及相同层级上的拥有相同的材质球参数的才合并在一起。合并成一个网格了就是一个静止的模型了,如果我们移动了任何元素,或者销毁了任何元素,或者改变了任何元素的材质球参数,UGUI则会销毁这个网格,重新构建一个新的。我们设想下,如果我们每时每刻都在移动一个元素的话,UGUI就会不停的拆分合并拆分合并,就会不停的消耗CPU,来使得画面保持应该有的样子。

因为这些合并和拆分的操作会消耗很多CPU,UI系统要做的就是尽一切可能节省些CPU消耗,把尽量多的剩余CPU让给项目逻辑。UGUI在制作完成成品后性能优劣差距很多时候都会出现在这里,合并的最多的元素,拆分次数最少的UI,才能达到优秀的性能开销.

3D 物体尽量使用同一个材质 在同一个渲染队列中
UI 尽可能安排同一个图集的物体在一个绘制顺序里
美术 将多个物体的纹理合并在一起 地图和物体使用同一个物体 

### 图集
图集是将多个小纹理(Texture)打包成一张大纹理的技术。在 Unity UGUI 中,图集通常用于优化 UI 元素的渲染。
Unity UGUI 默认使用 Sprite Atlas 来管理图集 
如果 UI 元素使用不同的纹理,则无法合批。通过将多个纹理打包到图集中,可以让这些 UI 元素使用相同的纹理,从而满足合批的条件。如果两个物体使用相同的材质球但不同的纹理,则无法合批。
纹理只是材质球的一个参数

### 1. 静态合批技术
只要是合批都要是同一个材质球
https://blog.csdn.net/ww1351646544/article/details/139678759

将相同材质 并且 不动 的Mesh合并 成一个 大Mesh 
然后由 cpu合并为一次批次发送给GPU处理

在编辑场景时将GameObject设置为Static有何作⽤？
答：设置游戏对象为Static将会剔除(或禁⽤)⽹格对象当这些部分被静态物体挡住⽽不可⻅时。因 
此,在你的场景中的所有不会动的物体都应该标记为Static。

缺点 物体要是静态的
把所有的网格合并在一起 如果1000棵树 合并成一个网格

### 2. 动态合批
只要是合批都要是同一个材质球
CPU 根据 矩阵 来计算合批 物体的每个顶点对应的世界空间的坐标
GPU 根据 这些顶点和材质 来绘制出来
动态合批是引擎自动处理的

缺点 CPU要转化顶点为世界坐标系 大量的计算

### 3. GPU Instancing
本质提交一个物体 绘制出来这个物体的N个实例到不同的位置 1000棵树

### 4. SRP Batcher
可编程渲染管线
特别适用于场景中有大量使用相同材质但具有不同属性(如颜色、纹理等)的小物体的项目 
SRP Batcher 通过将材质数据存储在 GPU 的常量缓冲区中,减少了 CPU 和 GPU 之间的通信开销
颜色不同：有的草是绿色,有的草是黄色。
纹理不同：有的石头使用纹理 A,有的石头使用纹理 B

## RectTransform和Transform
RectTransform是Transform的子类,可以这样强制转换,反过来则不行
``` c#
gameObject.GetComponent<RectTransform>().anchoredPosition3D = newVector3(x,y,z);
```
”锚点“在”父物体“中的位置和样式,取值范围为0(父物体左下) - 1(父物体右上)。     
当值的最大和最小不相同的时候表示一个区间,这时锚点会散开,锚点的一边在最小值上,锚点的一边在最大值上,都一样的时候就会如上图在一个点上      
特性: 决定当父物体改变的时候子物体的位置和大小     

Transform组件只处理位置、角度、缩放
RectTransform在此基础上加入了矩阵相关 将UI元素当作矩形来处理
加入了中心点 锚点 长宽等属性 来更方便控制UI大小和分辨率自适应中的位置适应

**轴心点** 是以左下角为原点 0-1之间的

**锚点 anchor** **是以左下角为原点** 在分辨率自适应时 会起到作用  **锚点是点的话** 依赖锚点进行计算 可以根据位置进行自适应分辨率 最多使用 
**此时Pos XYZ即为以锚点为原点**,UI中心点离原点的位置 **使用九宫格可以调整锚点的位置**

**锚点是范围的话** **四条边到这个UI的距离** 背景图会使用范围来设置它 图片可能会有问题
根据范围进行自适应分辨率

RectTransform是继承transform的,它是针对unity中ui的,具体在表现上可以这样看待,凡是在canvas组件下或者具有canvas组件的2d对象,他都是recttransform组件,那些在3d空间下没有不受canvas控制的对象都是transfrom组件。       
关于recttransform的坐标设置,我们在设置ui对象的坐标的时候设置的都是recttransform的坐标,他是相对于自身锚点的,和父对象的中心点没有关系应该这样设置。    
RectTransform组件还有一个anchoredPosition字段,它是忽略z坐标的,一般使用anchoredPosition3D 进行设置     