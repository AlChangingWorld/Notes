
## 欧拉角与四元数

### 欧拉角
欧拉角就是我们生活中最常用的角度0-360 进行旋转 
任意旋转都可以分解成绕三个轴的旋转角 Inspector中的Rotation就是欧拉角
this.transform.eularAngles得到的就是欧拉角角度
Unity中的欧拉角是 Y,X,Z 顺序旋转 
官方文档是z,x,y 是世界坐标系下的旋转

优点是 直观易于理解 存储空间小 
缺点 同一旋转的表示不唯一 万向节死锁问题

1. 静态
即绕世界坐标系三个轴的旋转,由于物体旋转过程中坐标轴保持静⽌,所以称为静态。 
2. 动态
绕物体坐标系三个轴的旋转,由于物体旋转过程中坐标轴随着物体做相同的转动,所以称 为动态。 

### 万圣节死锁问题
可以把Unity中的x轴改成90° 后            
现在旋转Y Z轴都会旋转Z轴
当三个轴转动时 中间那个轴会在某种特定的情况下 转到和另一个轴相同的位置 无论这俩轴如何变化都只表现为一个轴
三个轴 变为了 俩个轴 

### 同一旋转的表示不唯一
30 和 360+30 表现的是一样的 

### 四元数 
用于表现旋转 Unity实际用的是四元数
四元数的取值是 180 ~ -180 之间

是以轴角对形式 绕着(x,y,z)轴 旋转B弧度
四元数Q = [cons(B/2), sin(B/2)x, sin(B/2)y, sin(B/2)z]

**四元数的优点**
1. 解决欧拉角的 **万向节死锁问题** 和 **同一旋转的表示不唯一**

2. **效率更高** 四元数乘法 和 旋转矩阵乘法 
存储空间 四元数 4浮点数 旋转矩阵 9浮点数
计算复杂度度低

3. 提供平滑插值 一般使用球面插值 避免了这种万向锁问题 而且总是沿着球面上的最短路径进行插值 避免了不自然的旋转或者角度跳跃

## Unity脚本生命周期和执行顺序
1. Awake 脚本挂载上或者是物体被创建出来 执行一次 类似于构造函数
2. OnEnable 脚本激活
3. Start 第一次帧更新之前调用  在Update中添加 脚本 会立刻执行Awake, 但是在执行完这一帧 在下一帧之前执行start
4. FixedUpdate 物理帧更新 可以自己进行设置
5. Update   逻辑更新
6. lateUpdate 摄像机帧更新 在Update和LateUpdate之间 Unity进行了一些处理 处理动画相关的更新 在Update中更新摄像机 可能会造成一些渲染错误
7. Disenable    脚本失活 失活后其他的函数不再执行了
8. OnDestory 物体销毁 调用一次 删除时先调用失活再调用销毁

## Unity协程
游戏中有时候会同时出现几十个怪物 一帧创建会卡顿
使用场景:
1. 异步加载文件
2. 异步下载文件
3. 场景异步加载
4. 批量创建时防止卡顿

协程可以分成两部分
1. 协程函数本体
2. 协程调度器
协程的本体本质上就是一个 C#的迭代器方法分步执行 加上 协程调度逻辑 实现的一套分时执行函数的规则 开
启协程方法就是将一个迭代器的返回值存储在unity内部的管理器中 通过Unity协程调度器管理协程函数

IEnumerator接口由一个属性和两个方法组成
1. Current属性可以获取集合中当前迭代位置的元素 可以不断的得到内容 查看满足条件了没
2. MoveNext方法将当前迭代位置推进到下一个位置,如果成功推进到下一个位置则返回true,否则已经推进到集合的末尾返回false
3. Reset方法可以将当前迭代位置设置为初始位置(该位置位于集合中第一个元素之前,所以当调用Reset方法后,再调用MoveNext方法,Curren值则为集合的第一个元素)

在遇到 yield return XXX语句之前,协程⽅法和⼀般的⽅法是相同的,也就是程序在执⾏到 yield return XXX语句之后,接着才会执⾏的是 StartCoroutine()⽅法之后的程序,⾛的还是单线程模式,
仅仅是将 yield return XXX语句之后的内容暂时挂起,等到特定的时间才执⾏。 

协同程序主要是Update()⽅法之后,LateUpdate()⽅法之前调⽤的
协程只会在脚本失活时 没有影响 其他情况协程会停止

**yield和IEnumerator什么关系**
yield是C#的关键字,其实就是快速定义迭代器的语法糖。只要是yield出现在其中的方法就会被编译器自动编译成一个迭代器,对于这样的函数可以称之为迭代器函数。
迭代器函数的返回值就是自动生成的迭代器类的一个对象

## RectTransform和Transform
