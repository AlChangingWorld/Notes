
## c#中的奇异递归模式
Curiously Recurring Template Pattern (CRTP)/泛基
``` c#
public abstract class MyBase
{
    public abstract MyBase Copy();
}
public class Player : MyBase
{
    public override MyBase Copy()
    {
        var copy = this;
        return copy;
    }
    public void Speak()
    {
        Console.WriteLine("Player Hello ");
    }
}
Player player = new Player();
var copy = player.Copy();
//copy.Speak(); //报错 因为copy现在是一个Player 但是点不出Speak
//Console.WriteLine(copy.GetType()); //Player
//Console.WriteLine(copy is MyBase); //ture
//Console.WriteLine(copy is Player); //ture
(copy as Player).Speak(); //成功
```
上面的需要转化因为返回的是父类容器装了子类 点不出子类的方法
不想转化所以搞了个泛型
``` c#
public abstract class MyBase<T>
{
    public abstract T Copy();
}
public class Player : MyBase<Player>
{
    public override Player Copy()
    {
        var copy = this;
        return copy;
    }
    public void Speak()
    {
        Console.WriteLine("Player Hello ");
    }
}
Player player = new Player();
var copy = player.Copy();
copy.Speak(); //成功
Console.WriteLine(copy.GetType()); //Player
Console.WriteLine(copy is MyBase<Player>); //ture
Console.WriteLine(copy is Player); //ture
```
这样写的话没有一点限制 就会导致派生类可以随便写

``` c#
 public class Monster : MyBase<int>
 {
     public override int Copy()
     {
         return 1;
     }
     public void Speak()
     {
         Console.WriteLine("Monster Hello ");
     }
 }
Monster monster = new Monster();
var copy = monster.Copy();
//copy.Speak(); //失败 
Console.WriteLine(copy.GetType()); //int32
Console.WriteLine(copy is MyBase<Monster>); //false
Console.WriteLine(copy is Monster); //false
```
而且 我们有时候想要在子类实例对象中中使用一些父类的方法
``` c#
public abstract class MyBase<T>
{
    public void UseBaseMethod()
    { 
        var copy = this.Copy(); 
        copy.BaseMethod(); //编译会失败 因为不确定copy的类型
    }
    protected abstract T Copy();
    private void BaseMethod()
    {
        Console.WriteLine("Base Hello");
    }
}
```
这时候 使用 进行限制就好了
``` c#
public abstract class MyBase<T> where T: MyBase<T> 

```


最后看一个算法
``` c#
public abstract class Base<T> where T : Base<T>
{
    public T Run()
    {
        this.Step1();
        this.Step2();
        return (T)this; //如果没有where T : Base<T> 作为限制 无法运行 因为不知道是否能强制转化 
    }
    protected abstract void Step1();
    protected abstract void Step2();
}
public class Monster:Base<int> 
var monster = new Monster();
monster.Run().SomeOtherMethod(); // return (int)monster 怎么能相互转换？ 所以要加入限制

public class Player : Base<Player>
{
    protected override void Step1()
    {
        Console.WriteLine("Step 1: Initialization");
    }

    protected override void Step2()
    {
        Console.WriteLine("Step 2: Processing Data");
    }
    public void SomeOtherMethod()
    {
        // 其他方法
        Console.WriteLine("other method");
    }
}
var algorithm = new Player();
algorithm.Run().SomeOtherMethod(); //子类使用父类的内容 链式访问
```

## Entity
一个实体基类 比如玩家 怪物 小动物的基类

## EntityState 
实体的状态基类 继承于Entity

有三个函数
Entiy