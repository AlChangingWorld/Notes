
**3C**
Character
Controller 
Camera

## c#中的奇异递归模式
Curiously Recurring Template Pattern (CRTP)/泛基
``` c#
public abstract class MyBase
{
    public abstract MyBase Copy();
}
public class Player : MyBase
{
    public override MyBase Copy()
    {
        var copy = this;
        return copy;
    }
    public void Speak()
    {
        Console.WriteLine("Player Hello ");
    }
}
Player player = new Player();
var copy = player.Copy();
//copy.Speak(); //报错 因为copy现在是一个Player 但是点不出Speak
//Console.WriteLine(copy.GetType()); //Player
//Console.WriteLine(copy is MyBase); //ture
//Console.WriteLine(copy is Player); //ture
(copy as Player).Speak(); //成功
```
上面的需要转化因为返回的是父类容器装了子类 点不出子类的方法
不想转化所以搞了个泛型
``` c#
public abstract class MyBase<T>
{
    public abstract T Copy();
}
public class Player : MyBase<Player>
{
    public override Player Copy()
    {
        var copy = this;
        return copy;
    }
    public void Speak()
    {
        Console.WriteLine("Player Hello ");
    }
}
Player player = new Player();
var copy = player.Copy();
copy.Speak(); //成功
Console.WriteLine(copy.GetType()); //Player
Console.WriteLine(copy is MyBase<Player>); //ture
Console.WriteLine(copy is Player); //ture
```
这样写的话没有一点限制 就会导致派生类可以随便写

``` c#
 public class Monster : MyBase<int>
 {
     public override int Copy()
     {
        return 1;
     }
     public void Speak()
     {
         Console.WriteLine("Monster Hello ");
     }
 }
Monster monster = new Monster();
var copy = monster.Copy();
//copy.Speak(); //失败 
Console.WriteLine(copy.GetType()); //int32
Console.WriteLine(copy is MyBase<Monster>); //false
Console.WriteLine(copy is Monster); //false
```
而且 我们有时候想要在子类实例对象中中使用一些父类的方法
``` c#
public abstract class MyBase<T>
{
    public void UseBaseMethod()
    { 
        var copy = this.Copy(); 
        copy.BaseMethod();      //编译会失败 因为不确定copy的类型
    }
    protected abstract T Copy();
    private void BaseMethod()
    {
        Console.WriteLine("Base Hello");
    }
}
```
这时候 使用 进行限制就好了
``` c#
public abstract class MyBase<T> where T: MyBase<T> 

```


最后看一个算法
``` c#
public abstract class Base<T> where T: Base<T>
{
    public T Run()
    {
        this.Step1();
        this.Step2();
        return (T)this; //如果没有where T : Base<T> 作为限制 无法运行 因为不知道是否能强制转化 
    }
    protected abstract void Step1();
    protected abstract void Step2();
}
public class Monster:Base<int> 
var monster = new Monster();
monster.Run().SomeOtherMethod(); // return (int)monster 怎么能相互转换？ 所以要加入限制

public class Player : Base<Player>
{
    protected override void Step1()
    {
        Console.WriteLine("Step 1: Initialization");
    }

    protected override void Step2()
    {
        Console.WriteLine("Step 2: Processing Data");
    }
    public void SomeOtherMethod()
    {
        // 其他方法
        Console.WriteLine("other method");
    }
}
var algorithm = new Player();
algorithm.Run().SomeOtherMethod(); //子类使用父类的内容 链式访问
```

## 特性
``` c#
[System.Serializable]
```
序列化 使对象可在 Unity 编辑器中显示
当你在 Unity 编辑器中创建一个类实例时，
只有被标记为 Serializable 的类才会在 Inspector 面板中显示。
如果没有这个特性,Unity 编辑器就无法将该类的成员显示出来，甚至无法在 Inspector 中修改它们的值。
序列化的意思是将对象的状态转化为可以存储和恢复的格式(比如保存到磁盘或传输到网络)。
在 Unity 中，序列化使得你可以把类的字段(如变量)保存到场景或预设文件中，这样你就可以在编辑器中调整它们，
而这些数据会保存在 Unity 的场景或预设文件中

可以在 Unity 编辑器的 Inspector 窗口中进行序列化(保存和显示)，并且它可以被 Unity 序列化系统识别和处理。
用途：通过将类标记为 [Serializable]，Unity 可以将该类的实例作为字段存储到 MonoBehaviour 中，允许你在 Unity 编辑器中直接调整字段的值，并且将它们保存在场景或预设中。

``` c#
[Header("Parameters Names")]
```
用于在 Unity 编辑器的 Inspector 窗口中给脚本的字段(变量)添加一个可视化的标题

## 哈希表
将字符串转换为一个唯一的整数哈希值 使用这个哈希值来高效地标识和查找动画参数。这样可以减少字符串查找的开销，提升性能。
``` c#
m_stateHash = Animator.StringToHash(stateName);
``` 

## 动画播放的全流程
动画控制器(Animator Controller) 定义了所有的动画状态和过渡关系。每个动画状态(如 Idle、Run、Jump 等)包含了一个或多个 Animation Clips。

状态机 根据当前的 参数值 决定动画的状态。例如：

speed > 0 时，切换到跑步动画。
isGrounded == false 时，切换到跳跃动画。

过渡(Transitions) 在两个动画状态之间进行切换，过渡条件由 参数值 控制。当条件满足时，过渡将发生。

触发器(Triggers) 用于处理瞬时的动画切换，如攻击、受伤等。触发器在设置为 true 后触发一次动画。

更新参数：动画的参数通常在代码中实时更新，通过 animator.SetInteger(), 
nimator.SetFloat(), animator.SetBool() 等方法传递给 Animator。根据这些参数,动画系统决定当前播放哪个动画。

## 摄像机组件
导入包 Cinemachine, Post Processing 波浪 模糊处理
主摄像机中加入组件 CinemachineBrain 摄像机处理
PlayerCamera是它的影子 不同体系 加CinemachineVirutalCamera Cinemachine Collider 希望进入墙体摄像机不用跟随